<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The C&C Corp chat</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="dm-sidebar">
        <div id="dm-header">Contacts</div>
        <div id="dm-list"></div>
    </div>

    <div id="chat-container">
        <div id="username-area">
            <div style="display:flex; align-items:center; gap:10px;">
                <button id="avatar-upload-btn" title="Set Avatar">
                    <img id="current-avatar-preview" src="placeholder-avatar.png" alt="Avatar">
                </button>
                <h3 id="chat-header-label">username:</h3>
            </div>
            
            <div id="username-controls">
                <input type="text" id="username-input" placeholder="whatr we callin ya">
                <button id="set-username-btn">Save</button>
            </div>
        </div>

        <div id="online-users-area">
            <h4>whos online:</h4>
            <ul id="online-users-list"></ul>
        </div>
        
        <div id="messages"></div>
        <div id="typing-indicator"></div>

        <div id="message-input-area">
            <div id="image-preview-area" style="display:none;">
                <img id="image-preview" src="" alt="Image Preview">
                <button id="remove-image-btn">X</button>
            </div>
            <textarea id="message-input" placeholder="type type type..." rows="1"></textarea>
            <input type="file" id="hidden-file-input" accept="image/*" style="display: none;">
            <button id="file-upload-btn" title="Upload Image">üìÅ</button>
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <div id="right-panel">
        <div class="panel-top-group">
            <div>
                <h4 class="panel-title">other stuff</h4>
                <button id="launch-custom-window-btn" class="panel-btn">resizable window</button>
            </div>
            <div>
                <h4 class="panel-title">voice chat</h4>
                <button id="vc-btn-join" class="panel-btn">Join Call</button>
                <div style="display: flex; gap: 5px;">
                    <button id="vc-btn-mute" class="panel-btn" style="display: none; flex: 1;">Mute</button>
                    <button id="vc-btn-leave" class="panel-btn" style="display: none; flex: 1; background-color: var(--color-vc-red); border-color: #a00;">Leave</button>
                </div>
                <ul id="vc-user-list"></ul>
                <div id="audio-container"></div>
            </div>
        </div>
        <div class="panel-bottom-group">
            <h4 class="panel-title">Browser</h4>
            <button id="btn-cloak-launcher" class="panel-btn">Launch New Tab</button>
            <div style="margin-bottom: 15px;"></div> 
            <h4 class="panel-title">Appearance</h4>
            <div class="settings-panel">
                <ul class="settings-list">
                    <li class="setting-item" style="flex-direction: column; align-items: stretch; gap: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="font-size:0.9em; color:#aaa;">Custom BG</span>
                            <div style="display: flex; gap: 5px;">
                                <button id="btn-bg-upload" class="panel-btn" style="font-size: 0.8em; margin: 0; width: auto; padding: 4px 8px;">Upload</button>
                                <button id="btn-bg-reset" class="panel-btn" style="font-size: 0.8em; margin: 0; width: auto; padding: 4px 8px; background-color: var(--color-vc-red);">Reset</button>
                            </div>
                        </div>
                        <input type="file" id="bg-upload-input" accept="image/*" style="display: none;">
                    </li>
                </ul>
            </div>
            <div class="dropdown-wrapper">
                <div class="dropdown-header" id="notif-dropdown-header">
                    <span>Notifications</span>
                    <span class="dropdown-arrow">‚ñº</span>
                </div>
                <div class="dropdown-content" id="notif-dropdown-content">
                    <ul class="settings-list">
                        <li class="setting-item"><span>Main Messages</span><input type="checkbox" id="setting-main" checked></li>
                        <li class="setting-item"><span>Private Messages</span><input type="checkbox" id="setting-pm" checked></li>
                        <li class="setting-item"><span>VC Joins/Leaves</span><input type="checkbox" id="setting-vc" checked></li>
                        <li class="setting-item"><span>Sound</span><input type="checkbox" id="setting-sound" checked></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'popup') {
        document.getElementById('right-panel').style.display = 'none';
        document.getElementById('main-wrapper').style.maxWidth = '100%';
    }

    const socket = io();

    // DOM Elements
    const messagesDiv = document.getElementById('messages');
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const onlineUsersList = document.getElementById('online-users-list');
    const launchCustomWindowBtn = document.getElementById('launch-custom-window-btn');
    const avatarUploadBtn = document.getElementById('avatar-upload-btn');
    const currentAvatarPreview = document.getElementById('current-avatar-preview');
    
    // VC Elements
    const vcBtnJoin = document.getElementById('vc-btn-join');
    const vcBtnMute = document.getElementById('vc-btn-mute');
    const vcBtnLeave = document.getElementById('vc-btn-leave'); 
    const vcUserList = document.getElementById('vc-user-list');
    const audioContainer = document.getElementById('audio-container');
    
    const fileUploadBtn = document.getElementById('file-upload-btn');
    const hiddenFileInput = document.getElementById('hidden-file-input');
    const imagePreviewArea = document.getElementById('image-preview-area');
    const imagePreview = document.getElementById('image-preview');
    const removeImageBtn = document.getElementById('remove-image-btn');
    const typingIndicator = document.getElementById('typing-indicator');

    // Sidebar
    const dmList = document.getElementById('dm-list');
    const chatHeaderLabel = document.querySelector('#username-area h3');
    const onlineUsersArea = document.getElementById('online-users-area');

    // Settings & Panels
    const btnCloakLauncher = document.getElementById('btn-cloak-launcher');
    const settingMain = document.getElementById('setting-main');
    const settingPM = document.getElementById('setting-pm');
    const settingVC = document.getElementById('setting-vc');
    const settingSound = document.getElementById('setting-sound');
    const btnBgUpload = document.getElementById('btn-bg-upload');
    const btnBgReset = document.getElementById('btn-bg-reset');
    const bgUploadInput = document.getElementById('bg-upload-input');
    const notifHeader = document.getElementById('notif-dropdown-header');
    const notifContent = document.getElementById('notif-dropdown-content');

    // State
    let currentUsername = '';
    let currentAvatarBase64 = ''; 
    let stagedImage = null; 
    let typingTimeout = null;
    const typingUsers = new Set();
    let currentChatMode = 'global'; 
    let currentDmTarget = null;
    let allUsersCache = []; 
    let unreadCounts = {}; 

    // Cache
    let globalMessagesCache = [];
    let dmMessagesCache = {}; 

    // VC State
    let localStream = null;
    let peers = {}; 
    let isInVC = false;
    let isMuted = false;
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // --- SIDEBAR LOGIC ---
    function renderSidebar() {
        dmList.innerHTML = '';
        const mainChatCard = document.createElement('div');
        mainChatCard.className = 'dm-user-card';
        if (currentChatMode === 'global') mainChatCard.classList.add('active');
        const mainWrapper = document.createElement('div');
        mainWrapper.className = 'dm-avatar-wrapper';
        const mainImg = document.createElement('img');
        mainImg.src = 'placeholder-avatar.png'; 
        const mainStatus = document.createElement('div');
        mainStatus.className = 'status-bubble status-online';
        mainWrapper.appendChild(mainImg);
        mainWrapper.appendChild(mainStatus);
        const mainName = document.createElement('div');
        mainName.className = 'dm-username';
        mainName.innerText = "Main Chat";
        mainChatCard.appendChild(mainWrapper);
        mainChatCard.appendChild(mainName);
        mainChatCard.onclick = () => switchToGlobal();
        dmList.appendChild(mainChatCard);

        const sortedUsers = [...allUsersCache].sort((a, b) => {
            if (a.online === b.online) return a.username.localeCompare(b.username);
            return a.online ? -1 : 1;
        });

        sortedUsers.forEach(u => {
            if (u.username === currentUsername) return;
            const card = document.createElement('div');
            card.className = 'dm-user-card';
            if (currentChatMode === 'dm' && currentDmTarget === u.username) card.classList.add('active');
            const wrapper = document.createElement('div');
            wrapper.className = 'dm-avatar-wrapper';
            const img = document.createElement('img');
            img.src = u.avatar || 'placeholder-avatar.png';
            const statusBubble = document.createElement('div');
            statusBubble.className = `status-bubble ${u.online ? 'status-online' : 'status-offline'}`;
            const unreadBadge = document.createElement('div');
            unreadBadge.className = 'unread-badge';
            if (unreadCounts[u.username] > 0) {
                unreadBadge.innerText = unreadCounts[u.username];
                unreadBadge.classList.add('visible');
            }
            wrapper.appendChild(img);
            wrapper.appendChild(statusBubble);
            wrapper.appendChild(unreadBadge);
            const name = document.createElement('div');
            name.className = 'dm-username';
            name.innerText = u.username;
            card.appendChild(wrapper);
            card.appendChild(name);
            card.onclick = () => switchToDm(u.username);
            dmList.appendChild(card);
        });
    }

    function switchToDm(targetUser) {
        currentChatMode = 'dm';
        currentDmTarget = targetUser;
        unreadCounts[targetUser] = 0;
        typingUsers.clear();
        updateTypingDisplay();
        renderSidebar();
        
        chatHeaderLabel.innerText = `Chat with ${targetUser}`;
        onlineUsersArea.style.display = 'none';
        
        messagesDiv.innerHTML = '';
        if (dmMessagesCache[targetUser]) {
            renderMessageBatch(dmMessagesCache[targetUser]);
        } else {
            socket.emit('fetch-dm-history', targetUser);
        }
    }

    function switchToGlobal() {
        currentChatMode = 'global';
        currentDmTarget = null;
        typingUsers.clear();
        updateTypingDisplay();
        renderSidebar();
        
        chatHeaderLabel.innerText = 'username:';
        onlineUsersArea.style.display = 'flex';
        
        messagesDiv.innerHTML = '';
        if (globalMessagesCache.length > 0) {
            renderMessageBatch(globalMessagesCache);
        } else {
            socket.emit('get-history');
        }
    }

    // --- SCROLL HELPER (NEW) ---
    function forceScrollToBottom() {
        // Use a slightly delayed scroll to account for layout shifts
        setTimeout(() => {
            messagesDiv.scrollTop = messagesDiv.scrollHeight + 1000;
        }, 10);
        // Double check after render
        setTimeout(() => {
            messagesDiv.scrollTop = messagesDiv.scrollHeight + 1000;
        }, 100);
    }

    // --- SOCKET HANDLERS ---
    socket.on('sidebar-user-list', (list) => { allUsersCache = list; renderSidebar(); });
    socket.on('user-status-change', (data) => {
        const user = allUsersCache.find(u => u.username === data.username);
        if (user) { user.online = data.online; if(data.avatar) user.avatar = data.avatar; } 
        else { allUsersCache.push({ username: data.username, online: data.online, avatar: data.avatar }); }
        renderSidebar();
    });
    
    socket.on('dm-history', (data) => {
        dmMessagesCache[data.target] = data.messages;
        if (currentChatMode === 'dm' && currentDmTarget === data.target) {
            messagesDiv.innerHTML = '';
            renderMessageBatch(data.messages);
        }
    });
    
    socket.on('history', (history) => {
        globalMessagesCache = history; 
        if (currentChatMode === 'global') {
            messagesDiv.innerHTML = '';
            renderMessageBatch(history);
        }
    });

    socket.on('dm-received', (data) => {
        const partner = (data.from === currentUsername) ? data.to : data.from;
        if (!dmMessagesCache[partner]) dmMessagesCache[partner] = [];
        dmMessagesCache[partner].push(data.message);

        if (currentChatMode === 'dm' && (data.from === currentDmTarget || data.to === currentDmTarget)) {
            appendMessageToUI(data.message);
        } else if (data.from !== currentUsername) {
            if (!unreadCounts[data.from]) unreadCounts[data.from] = 0;
            unreadCounts[data.from]++;
            renderSidebar();
        }
    });

    socket.on('chat-message', (msg) => { 
        globalMessagesCache.push(msg);
        if (currentChatMode === 'global') appendMessageToUI(msg); 
    });

    // --- CHAT LOGIC ---
    function sendMessage() {
        const text = messageInput.value.trim();
        if ((!text && !stagedImage) || !currentUsername) return; 
        if (currentChatMode === 'global') socket.emit('chat-message', { text: text, image: stagedImage });
        else socket.emit('send-dm', { target: currentDmTarget, message: text, image: stagedImage });
        messageInput.value = ''; stagedImage = null; imagePreviewArea.style.display = 'none'; hiddenFileInput.value = '';
        const scope = currentChatMode === 'global' ? 'global' : currentDmTarget;
        socket.emit('typing-stop', scope);
        if (typingTimeout) clearTimeout(typingTimeout);
    }
    
    messageInput.addEventListener('input', () => { 
        if (!currentUsername) return; 
        const scope = currentChatMode === 'global' ? 'global' : currentDmTarget;
        socket.emit('typing-start', scope); 
        if (typingTimeout) clearTimeout(typingTimeout); 
        typingTimeout = setTimeout(() => { socket.emit('typing-stop', scope); }, 2000); 
    });
    socket.on('user-typing', (data) => {
        if ((currentChatMode === 'global' && data.scope === 'global') || 
            (currentChatMode === 'dm' && data.scope === 'dm' && data.username === currentDmTarget)) {
            typingUsers.add(data.username); updateTypingDisplay();
        }
    });
    socket.on('user-stopped-typing', (data) => { typingUsers.delete(data.username); updateTypingDisplay(); });
    function updateTypingDisplay() { 
        if (typingUsers.size > 0) { const names = Array.from(typingUsers).join(', '); typingIndicator.innerText = `${names} is typing...`; typingIndicator.classList.add('active'); } 
        else { typingIndicator.classList.remove('active'); } 
    }

    // --- RENDER HELPERS ---
    function parseFormatting(text) { if (!text) return ''; return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/~~(.*?)~~/g, '<del>$1</del>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>'); }
    
    function createMessageElement(msg) {
        if (msg.type === 'system') {
            const sysDiv = document.createElement('div');
            sysDiv.className = 'system-message';
            sysDiv.innerText = msg.text;
            return sysDiv;
        }

        const messageEl = document.createElement('div');
        messageEl.classList.add('message');
        if (msg.type === 'private' || msg.type === 'pm') {
            const isMe = (msg.sender === currentUsername);
            isMe ? messageEl.classList.add('user-message') : messageEl.classList.add('other-message');
            messageEl.classList.add('dm-message-item'); 
        } else {
             const isMe = (msg.sender === currentUsername);
             isMe ? messageEl.classList.add('user-message') : messageEl.classList.add('other-message');
        }
        
        const contentArea = document.createElement('div');
        contentArea.classList.add('message-content-area');
        if (msg.type === 'private' || msg.type === 'pm') contentArea.classList.add('private-message-container');
        
        const contentWrapper = document.createElement('div');
        contentWrapper.classList.add('message-content-wrapper');
        
        const bubbleContent = document.createElement('div');
        bubbleContent.classList.add('bubble-content');
        if (msg.type === 'private' || msg.type === 'pm') bubbleContent.classList.add('bubble-private');
        
        if (msg.image) {
            const img = document.createElement('img');
            img.src = msg.image; 
            img.classList.add('message-image');
            img.onclick = () => { const w = window.open(""); w.document.write(`<img src="${msg.image}" style="width:100%">`); };
            // Auto scroll when image loads
            img.onload = () => forceScrollToBottom();
            bubbleContent.appendChild(img);
        }
        
        if (msg.text) {
            const textSpan = document.createElement('span');
            textSpan.innerHTML = parseFormatting(msg.text);
            bubbleContent.appendChild(textSpan);
        }
        
        const timeDiv = document.createElement('div');
        timeDiv.classList.add('message-time');
        timeDiv.textContent = msg.time;
        
        contentWrapper.appendChild(bubbleContent);
        contentWrapper.appendChild(timeDiv);
        contentArea.appendChild(contentWrapper);
        
        if (msg.avatar) {
            const avatarImg = document.createElement('img');
            avatarImg.src = msg.avatar; avatarImg.classList.add('avatar');
            messageEl.appendChild(avatarImg);
        }
        
        messageEl.appendChild(contentArea);
        return messageEl;
    }

    // BATCH RENDER (Switching Chats) - Always Bottom
    function renderMessageBatch(messages) {
        const fragment = document.createDocumentFragment();
        messages.forEach(msg => {
            fragment.appendChild(createMessageElement(msg));
        });
        messagesDiv.appendChild(fragment);
        forceScrollToBottom(); // FORCE BOTTOM ON SWITCH
    }

    // SINGLE APPEND (Live) - Smart Scroll
    function appendMessageToUI(msg) {
        // Notifications
        if (msg.sender !== currentUsername && currentChatMode === 'global') {
            if (msg.type === 'private' && settingPM.checked) triggerNotification(`Private from ${msg.sender}`, msg.text || 'Sent an image');
            else if (msg.type === 'system' && settingVC.checked && msg.text.includes('Voice Chat')) triggerNotification('Voice Chat', msg.text);
            else if (msg.type === 'general' && settingMain.checked) triggerNotification(`${msg.sender}`, msg.text || 'Image');
        }

        // Logic: Are we near bottom? (within 100px)
        const threshold = 100;
        const isNearBottom = (messagesDiv.scrollHeight - messagesDiv.scrollTop - messagesDiv.clientHeight) < threshold;
        
        const el = createMessageElement(msg);
        messagesDiv.appendChild(el);

        // Scroll ONLY if user sent it OR they were already near bottom
        if (msg.sender === currentUsername || isNearBottom) {
            forceScrollToBottom();
        }
    }

    // --- VC Logic ---
    function createPeer(targetId, initiator = false) {
        const p = new RTCPeerConnection(rtcConfig);
        p.onicecandidate = (e) => { if (e.candidate) socket.emit('signal', { target: targetId, signal: { candidate: e.candidate } }); };
        p.ontrack = (e) => { const audio = document.createElement('audio'); audio.srcObject = e.streams[0]; audio.autoplay = true; audio.id = `audio-${targetId}`; audioContainer.appendChild(audio); };
        if (localStream) localStream.getTracks().forEach(track => p.addTrack(track, localStream));
        return p;
    }
    vcBtnJoin.onclick = async () => {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            socket.emit('vc-join'); isInVC = true;
            vcBtnJoin.style.display = 'none'; vcBtnMute.style.display = 'inline-block'; vcBtnLeave.style.display = 'inline-block'; vcBtnMute.innerText = "Mute";
        } catch (err) { alert("Could not access microphone."); console.error(err); }
    };
    vcBtnMute.onclick = () => { if(localStream) { isMuted = !isMuted; localStream.getAudioTracks()[0].enabled = !isMuted; vcBtnMute.innerText = isMuted ? "Unmute" : "Mute"; vcBtnMute.style.backgroundColor = isMuted ? "grey" : "var(--color-accent-blue)"; socket.emit('vc-mute-toggle', isMuted); } };
    vcBtnLeave.onclick = () => { if (isInVC) { socket.emit('vc-leave'); isInVC = false; if (localStream) { localStream.getTracks().forEach(track => track.stop()); localStream = null; } Object.keys(peers).forEach(id => { peers[id].close(); delete peers[id]; }); document.getElementById('audio-container').innerHTML = ''; vcBtnJoin.style.display = 'inline-block'; vcBtnMute.style.display = 'none'; vcBtnLeave.style.display = 'none'; isMuted = false; vcBtnMute.innerText = "Mute"; vcBtnMute.style.backgroundColor = ""; } };
    socket.on('vc-prepare-connection', async (initiatorId) => { if (!isInVC) return; const peer = createPeer(initiatorId, true); peers[initiatorId] = peer; const offer = await peer.createOffer(); await peer.setLocalDescription(offer); socket.emit('signal', { target: initiatorId, signal: { type: 'offer', sdp: peer.localDescription } }); });
    socket.on('signal', async ({ sender, signal }) => { if (!isInVC) return; let peer = peers[sender]; if (!peer) { peer = createPeer(sender, false); peers[sender] = peer; } if (signal.type === 'offer') { await peer.setRemoteDescription(new RTCSessionDescription(signal.sdp)); const answer = await peer.createAnswer(); await peer.setLocalDescription(answer); socket.emit('signal', { target: sender, signal: { type: 'answer', sdp: peer.localDescription } }); } else if (signal.type === 'answer') { await peer.setRemoteDescription(new RTCSessionDescription(signal.sdp)); } else if (signal.candidate) { await peer.addIceCandidate(new RTCIceCandidate(signal.candidate)); } });
    socket.on('vc-user-left', (id) => { if (peers[id]) { peers[id].close(); delete peers[id]; } const audioEl = document.getElementById(`audio-${id}`); if (audioEl) audioEl.remove(); });
    socket.on('vc-user-list-update', (users) => { vcUserList.innerHTML = ''; users.forEach(u => { const li = document.createElement('li'); li.innerHTML = `<span>${u.username}</span> ${u.isMuted ? '<span style="color:red">(Muted)</span>' : ''}`; vcUserList.appendChild(li); }); });

    // --- GENERIC UI ---
    if (btnCloakLauncher) btnCloakLauncher.onclick = () => { const newWindow = window.open('about:blank', '_blank'); if (!newWindow) return; newWindow.document.write(`<!DOCTYPE html><html><head><title>New Tab</title><style>body{margin:0;overflow:hidden;background:#000;}iframe{border:none;width:100vw;height:100vh;display:block;}</style></head><body><iframe src="https://tuff.speedslicer.dev/files/1_1UT8/WASM/"></iframe></body></html>`); };
    if(launchCustomWindowBtn) launchCustomWindowBtn.onclick = () => window.open(window.location.href + '?mode=popup', 'ChatWindow', 'width=400,height=600,resizable=yes');
    socket.on('update-user-list', (users) => { onlineUsersList.innerHTML = ''; users.forEach(user => { const li = document.createElement('li'); li.innerHTML = `<span style="width:10px;height:10px;background:#4caf50;border-radius:50%;display:inline-block;"></span> ${user.username}`; onlineUsersList.appendChild(li); }); });
    notifHeader.onclick = () => { notifHeader.classList.toggle('active'); notifContent.classList.toggle('show'); };
    const loadSetting = (key, checkbox) => { const saved = localStorage.getItem(key); if (saved !== null) checkbox.checked = (saved === 'true'); }; loadSetting('notif-main', settingMain); loadSetting('notif-pm', settingPM); loadSetting('notif-vc', settingVC); loadSetting('notif-sound', settingSound);
    const savedBg = localStorage.getItem('custom-bg'); if (savedBg) { document.body.style.backgroundImage = `url(${savedBg})`; document.body.classList.add('transparent-mode'); }
    [settingMain, settingPM, settingVC, settingSound].forEach(el => el.onchange = () => { localStorage.setItem(el.id.replace('setting-', 'notif-'), el.checked); if (Notification.permission === 'default') Notification.requestPermission(); });
    btnBgUpload.onclick = () => bgUploadInput.click(); bgUploadInput.onchange = (e) => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (evt) => { localStorage.setItem('custom-bg', evt.target.result); document.body.style.backgroundImage = `url(${evt.target.result})`; document.body.classList.add('transparent-mode'); }; reader.readAsDataURL(file); } };
    btnBgReset.onclick = () => { localStorage.removeItem('custom-bg'); document.body.style.backgroundImage = ''; document.body.classList.remove('transparent-mode'); };
    function playNotificationSound() { if (!settingSound.checked) return; const ctx = new (window.AudioContext || window.webkitAudioContext)(); const osc = ctx.createOscillator(); const gain = ctx.createGain(); osc.connect(gain); gain.connect(ctx.destination); osc.type = 'sine'; osc.frequency.setValueAtTime(500, ctx.currentTime); gain.gain.setValueAtTime(0.1, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.1); osc.start(); osc.stop(ctx.currentTime + 0.1); }
    function triggerNotification(title, body) { if (document.hidden && Notification.permission === 'granted') { const n = new Notification(title, { body: body, icon: 'placeholder-avatar.png', requireInteraction: true }); playNotificationSound(); } }
    fileUploadBtn.onclick = () => hiddenFileInput.click(); hiddenFileInput.onchange = (e) => handleFileSelection(e.target.files[0]);
    function handleFileSelection(file) { if (!file || !file.type.startsWith('image/')) return; const reader = new FileReader(); reader.onload = (e) => { stagedImage = e.target.result; imagePreview.src = stagedImage; imagePreviewArea.style.display = 'flex'; }; reader.readAsDataURL(file); }
    messageInput.onpaste = (e) => { const items = (e.clipboardData || e.originalEvent.clipboardData).items; for (let item of items) if (item.kind === 'file' && item.type.startsWith('image/')) handleFileSelection(item.getAsFile()); };
    removeImageBtn.onclick = () => { stagedImage = null; imagePreview.src = ''; imagePreviewArea.style.display = 'none'; hiddenFileInput.value = ''; };
    avatarUploadBtn.onclick = () => { const i = document.createElement('input'); i.type = 'file'; i.accept = 'image/*'; i.onchange = (e) => { const f = e.target.files[0]; if(f){ const r = new FileReader(); r.onload = () => { currentAvatarBase64 = r.result; currentAvatarPreview.src = r.result; if(currentUsername) socket.emit('set-username', {username: currentUsername, avatar: currentAvatarBase64}); localStorage.setItem('chatAvatar', currentAvatarBase64); }; r.readAsDataURL(f); } }; i.click(); };
    document.addEventListener('DOMContentLoaded', () => { const u = localStorage.getItem('chatUsername'); const a = localStorage.getItem('chatAvatar'); if(a) { currentAvatarBase64 = a; currentAvatarPreview.src = a; } if(u) { usernameInput.value = u; socket.emit('set-username', {username: u, avatar: a}); currentUsername = u; usernameInput.disabled = true; setUsernameBtn.disabled = true; } });
    setUsernameBtn.onclick = () => { const u = usernameInput.value.trim(); if(u) { localStorage.setItem('chatUsername', u); currentUsername = u; socket.emit('set-username', {username: u, avatar: currentAvatarBase64 || 'placeholder-avatar.png'}); usernameInput.disabled = true; setUsernameBtn.disabled = true; } };
    sendButton.onclick = sendMessage; messageInput.onkeydown = (e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } };
</script>
</body>
</html>
