<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple Chat App</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="chat-container">
        <div id="username-area">
            <h3>username:</h3>
            <input type="text" id="username-input" placeholder="whatr we callin ya">
            <button id="set-username-btn">Save</button>
        </div>

        <div id="online-users-area">
            <h4>whos online:</h4>
            <ul id="online-users-list">
                </ul>
        </div>
        
        <div id="messages">
            </div>

        <div id="message-input-area">
            <textarea id="message-input" placeholder="type type type..." rows="1"></textarea>
            <button id="file-upload-btn" title="File Upload (Not implemented)">
                üìÅ
            </button>
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <div id="right-panel">
        <h4 class="panel-title">other stuff</h4>
        <button id="launch-custom-window-btn" class="panel-btn">resizable window</button>
        <p class="panel-hint"></p>
        
        <h4 class="panel-title">voice chat</h4>
        <div id="vc-area">
            <div id="vc-controls">
                <button id="vc-btn-join" class="panel-btn">Join Call</button>
                <button id="vc-btn-mute" class="vc-btn-mute" style="display: none;">Mute</button>
                <button id="vc-btn-leave" class="vc-btn-leave" style="display: none;">Leave</button>
            </div>
            <ul id="vc-user-list">
                </ul>
        </div>
        </div>
    
</div>

<script>
    // --- 0. Popup Mode Check (CRITICAL: Hides the side panel when URL contains ?mode=popup) ---
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'popup') {
        const mainWrapper = document.getElementById('main-wrapper');
        const rightPanel = document.getElementById('right-panel');
        const chatContainer = document.getElementById('chat-container');
        
        // NEW: Selectors for Input Area elements
        const messageInputArea = document.getElementById('message-input-area');
        const fileUploadBtn = document.getElementById('file-upload-btn');
        const sendButton = document.getElementById('send-button');


        if (mainWrapper) {
            // Remove the gap
            mainWrapper.style.gap = '0';
            // FIX: Set the maximum content width to 150px in popup mode
            mainWrapper.style.maxWidth = '150px'; 
        }
        if (rightPanel) {
            // Hide the side panel
            rightPanel.style.display = 'none';
        }
        if (chatContainer) {
            // Ensure the chat container fills the available wrapper space
            chatContainer.style.maxWidth = '100%';
        }

        // --- NEW INPUT LAYOUT FOR POPUP MODE ---
        if (messageInputArea) {
            // 1. Change the input area to a vertical stack
            messageInputArea.style.flexDirection = 'column';
            // 2. Add padding/gap back manually
            messageInputArea.style.gap = '5px';
        }
        if (fileUploadBtn) {
            // 3. Make buttons full width to span the column
            fileUploadBtn.style.width = '100%';
            fileUploadBtn.style.alignSelf = 'stretch';
        }
        if (sendButton) {
            // 3. Make buttons full width to span the column
            sendButton.style.width = '100%';
            sendButton.style.alignSelf = 'stretch';
        }
        // --- END NEW INPUT LAYOUT ---
    }
    // ------------------------------------

    const socket = io();

    // --- DOM Elements ---
    const messagesDiv = document.getElementById('messages');
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const onlineUsersList = document.getElementById('online-users-list');
    // New Button
    const launchCustomWindowBtn = document.getElementById('launch-custom-window-btn');
    
    // NEW VC Elements
    const vcBtnJoin = document.getElementById('vc-btn-join');
    const vcBtnMute = document.getElementById('vc-btn-mute');
    const vcBtnLeave = document.getElementById('vc-btn-leave');
    const vcUserList = document.getElementById('vc-user-list');


    let currentUsername = '';
    let lastUserMessageTime = 0; 
    let lastOtherMessageSender = ''; 
    
    // NEW VC State
    let localStream = null; 
    const peerConnections = {}; // Stores RTCPeerConnection objects: { socketId: RTCPeerConnection }
    let isMuted = false;


    // --- 1. Utility Function to Handle Formatting ---
    function parseFormatting(text) {
        let formattedText = text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        // Crossout: ~~text~~ with <del>text</del>
        formattedText = formattedText.replace(/~~(.*?)~~/g, '<del>$1</del>');
        
        // Bold: **text** with <strong>text</strong>
        formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        // Underline: __text__ with <u>text</u>
        formattedText = formattedText.replace(/__(.*?)\b__/g, '<u>$1</u>'); 
        
        // Slanted (Italics): *text* with <em>text</em>
        formattedText = formattedText.replace(/\*(.*?)\*/g, '<em>$1</em>');
        
        // UNSANITIZE only the newly added HTML tags for rendering
        formattedText = formattedText.replace(/&lt;del&gt;/g, '<del>').replace(/&lt;\/del&gt;/g, '</del>');
        formattedText = formattedText.replace(/&lt;strong&gt;/g, '<strong>').replace(/&lt;\/strong&gt;/g, '</strong>');
        formattedText = formattedText.replace(/&lt;u&gt;/g, '<u>').replace(/&lt;\/u&gt;/g, '</u>');
        formattedText = formattedText.replace(/&lt;em&gt;/g, '<em>').replace(/&lt;\/em&gt;/g, '</em>');

        return formattedText;
    }

    // --- 2. Username Handling ---
    
    document.addEventListener('DOMContentLoaded', () => {
        const storedUsername = localStorage.getItem('chatUsername');
        if (storedUsername) {
            usernameInput.value = storedUsername;
            setUsername(storedUsername);
        }
    });

    setUsernameBtn.addEventListener('click', () => {
        const username = usernameInput.value.trim();
        if (username) {
            localStorage.setItem('chatUsername', username);
            setUsername(username);
        } else {
            // Using console warning instead of intrusive alert
            console.warn('Please enter a username.');
        }
    });
    
    function setUsername(username) {
        currentUsername = username;
        socket.emit('set-username', currentUsername); 
        usernameInput.disabled = true;
        setUsernameBtn.disabled = true;
        usernameInput.placeholder = 'Username set!';
        messageInput.focus();
    }

    // --- 3. Message Sending ---

    function sendMessage() {
        let msg = messageInput.value.trim();
        if (!msg || !currentUsername) return; 

        socket.emit('chat-message', msg);
        messageInput.value = '';
    }

    sendButton.addEventListener('click', sendMessage);

    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // --- 4. Message Display Helper Function (Grouping Logic) ---
    function displayMessage(formattedMessage) {
        const messageEl = document.createElement('div');
        messageEl.classList.add('message');

        // Regex 1: Regular messages (HAS colon) **[User]**: [Message Text] [Time]
        const fullMatch = formattedMessage.match(/\*\*(.*?)\*\*: (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);

        // --- Handle System Messages/Announcements ---
        if (!fullMatch) {
            // Check for the System format: **[User]** [Message Text] [Time] (No colon)
            const systemMatch = formattedMessage.match(/\*\*(.*?)\*\* (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);
            
            // CRITICAL: Reset trackers on system message
            lastUserMessageTime = 0; 
            lastOtherMessageSender = ''; 

            if (systemMatch) {
                messageEl.classList.add('system-message');
                const systemText = systemMatch[2];
                
                // NEW: Private Message Check (uses the specific tags we set in server.js)
                if (systemText.startsWith('**[PM from') || systemText.startsWith('**[PM to')) {
                    messageEl.classList.add('private-message');
                    // Remove the surrounding bolding and colon introduced by the server's formatMessage
                    let pmContent = systemText.replace(/\*\*(.*?)\*\*/, '$1'); 
                    
                    // We wrap the entire content in <u> tags to force underline
                    // The inner message (e.g., 'hi') is already bolded by the server.
                    messageEl.innerHTML = parseFormatting(`<u>${pmContent}</u>`); 

                    messagesDiv.appendChild(messageEl);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    return; // PM handled, exit function
                }
                
                // Standard System Message / Announcement
                messageEl.innerHTML = parseFormatting(systemText);
                messagesDiv.appendChild(messageEl);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                return;
            }
            
            // Fallback for unparseable system messages/errors
            messageEl.classList.add('system-message');
                messageEl.innerHTML = parseFormatting(formattedMessage);
                messagesDiv.appendChild(messageEl);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                return;
        }
        
        // Extracted parts for REGULAR messages:
        const sender = fullMatch[1];
        const messageText = fullMatch[2];
        const timeString = fullMatch[3]; 

        // 1. Determine alignment class, tracking variables, and grouping logic
        const isUserMessage = (sender === currentUsername);
        let showTime = true; 
        let showUsername = true; 

        // --- Calculate Time in Minutes for Grouping ---
        let currentTimeInMinutes = 0;
        const timeParts = timeString.match(/(\d{1,2}):(\d{2}) (AM|PM)/);
        if (timeParts) {
            let hours = parseInt(timeParts[1]);
            const minutes = parseInt(timeParts[2]);
            const isPM = timeParts[3] === 'PM';
            
            if (isPM && hours !== 12) hours += 12;
            if (!isPM && hours === 12) hours = 0;
            currentTimeInMinutes = hours * 60 + minutes;
        }


        // 1a. Set base alignment/username visibility
        if (isUserMessage) {
            messageEl.classList.add('user-message');
            showUsername = false; // Never show username on self-messages
        } else {
            messageEl.classList.add('other-message');
        }


        // 1b. Unified Grouping Logic (Applies to Both User and Other Messages)
        let lastSender = isUserMessage ? currentUsername : lastOtherMessageSender;
        let lastTime = lastUserMessageTime;
        let currentSender = sender;

        // Check if this message should be grouped with the previous one
        const shouldGroup = (lastSender === currentSender) && (currentTimeInMinutes - lastTime) < 1;

        if (shouldGroup) {
            showUsername = false; 
            messageEl.classList.add('grouped-message');

            // === CRITICAL RETROACTIVE FIX (Removes time from the previous message) ===
            const previousMessageEl = messagesDiv.lastChild;
            if (previousMessageEl) {
                const prevContentWrapper = previousMessageEl.querySelector('.message-content-wrapper');
                if (prevContentWrapper) {
                    const prevTimeSpan = prevContentWrapper.querySelector('.message-time');
                    if (prevTimeSpan) {
                        prevTimeSpan.remove(); // DELETE TIME from the previous message
                    }
                }
            }
            // =======================================================================

        } else {
            // If not grouped, reset the opposing sender's tracker to break future grouping blocks
            if (isUserMessage) {
                lastOtherMessageSender = '';
            } else {
                lastUserMessageTime = 0; // Reset other user's time tracker
            }
        }

        // 1c. Update Tracking Variables (After Grouping Check)
        if (isUserMessage) {
            lastUserMessageTime = currentTimeInMinutes;
        } else {
            lastOtherMessageSender = currentSender;
            lastUserMessageTime = currentTimeInMinutes; // Use the same time tracker for all users
        }


        // --- 2. Assemble the Message Structure ---
        
        // 2a. Username (ONLY for other users, above the bubble, when showUsername is true)
        if (showUsername && !isUserMessage) {
            const usernameDiv = document.createElement('div');
            usernameDiv.classList.add('message-username');
            usernameDiv.innerHTML = `<strong>${sender}</strong><span class="username-separator">:</span>`;
            messageEl.appendChild(usernameDiv);
        }

        // 2b. Content Wrapper (Bubble + Time)
        const contentWrapper = document.createElement('div');
        contentWrapper.classList.add('message-content-wrapper');
        
        const bubbleContent = document.createElement('span');
        bubbleContent.classList.add('bubble-content');
        
        let contentHtml = parseFormatting(messageText); 

        bubbleContent.innerHTML = contentHtml;
        contentWrapper.appendChild(bubbleContent); 
        
        // 2c. Time Content (Renders only for the last message because previous times were removed)
        if (showTime) {
            const timeSpan = document.createElement('span');
            timeSpan.classList.add('message-time');
            timeSpan.textContent = timeString; 
            contentWrapper.appendChild(timeSpan); 
        }

        // 3. Assemble the final message element
        messageEl.appendChild(contentWrapper);
        
        messagesDiv.appendChild(messageEl);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // --- 5. Receiving Messages (History and Live) ---
    
    socket.on('history', (history) => {
        // Reset trackers before starting the loop
        lastUserMessageTime = 0; 
        lastOtherMessageSender = ''; 
        messagesDiv.innerHTML = ''; 

        // Loop through history messages sequentially
        history.forEach(msg => {
            displayMessage(msg);
        });
        
        messagesDiv.scrollTop = messagesDiv.scrollHeight; 
    });

    socket.on('chat-message', (formattedMessage) => {
        displayMessage(formattedMessage);
    });

    socket.on('clear-chat', () => {
        messagesDiv.innerHTML = '';
    });

    // --- 6. Online User List Update ---
    
    socket.on('user-list-update', (users) => {
        onlineUsersList.innerHTML = '';
        users.forEach(user => {
            const li = document.createElement('li');
            li.textContent = user;
            onlineUsersList.appendChild(li);
        });
    });

    // --- 7. Launch Custom Window Logic (UPDATED) ---
    if (launchCustomWindowBtn) {
         launchCustomWindowBtn.addEventListener('click', () => {
            // Get the current URL root (removing any existing query params)
            const currentUrl = window.location.href.split('?')[0]; 
            // Add the new popup flag to the URL
            const newUrl = `${currentUrl}?mode=popup`; 
            
            // Open a new window with a width of 200px and a height of 700px
            window.open(newUrl, '_blank', 'width=200,height=700,resizable=yes');
        });
    }

    // --- 8. VOICE CHAT IMPLEMENTATION (WebRTC & Socket.IO Signaling) ---

    // --- UI Control ---
    function updateVcControls(inCall) {
        vcBtnJoin.style.display = inCall ? 'none' : 'block';
        vcBtnMute.style.display = inCall ? 'block' : 'block'; // Always visible when not joined to enable pre-mute
        vcBtnLeave.style.display = inCall ? 'block' : 'none';
        
        // Ensure mute button reflects state
        if (inCall) {
            vcBtnMute.textContent = isMuted ? 'Unmute' : 'Mute';
            vcBtnMute.classList.toggle('active', isMuted);
        } else {
            // Display only a generic Mute button when not in call (as a preference)
            vcBtnMute.textContent = 'Mute';
            vcBtnMute.classList.remove('active');
        }
    }

    // --- VC Connect ---
    vcBtnJoin.addEventListener('click', async () => {
        if (!currentUsername) {
            console.warn('Set a username before joining the voice chat.');
            return;
        }
        try {
            // 1. Get user's microphone stream
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            
            // 2. Apply initial mute state
            localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);

            // 3. Signal to the server that we are joining
            socket.emit('vc-join');
            updateVcControls(true);

            // 4. Creation of connections with peers is handled by the 'vc-user-joined' event from the server.
            
        } catch (err) {
            console.error('Failed to get local audio stream (User denied access or no device):', err);
            // Fallback UI or error message
            updateVcControls(false); 
        }
    });

    // --- VC Mute/Unmute ---
    vcBtnMute.addEventListener('click', () => {
        isMuted = !isMuted;
        if (localStream) {
            localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
        }
        updateVcControls(localStream !== null); // Update button text/class
    });

    // --- VC Leave ---
    vcBtnLeave.addEventListener('click', () => {
        socket.emit('vc-leave');
        
        // 1. Close all peer connections
        Object.values(peerConnections).forEach(pc => pc.close());
        
        // 2. Stop local audio tracks
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        
        // 3. Clean up
        localStream = null;
        Object.keys(peerConnections).forEach(key => delete peerConnections[key]);
        // Remove all dynamically created remote audio elements
        document.querySelectorAll('audio[id^="audio-"]').forEach(el => el.remove());

        updateVcControls(false);
    });

    // --- Peer Connection Handling ---

    // Utility to create a new RTCPeerConnection
    function createPeerConnection(remoteSocketId) {
        const pc = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' } // Standard STUN server
            ]
        });

        pc.onicecandidate = ({ candidate }) => {
            // 1. Send ICE candidates to the remote peer via the server
            if (candidate) {
                socket.emit('webrtc-signal', remoteSocketId, { 'ice-candidate': candidate });
            }
        };

        pc.ontrack = ({ streams: [stream] }) => {
            // 2. When a remote stream is received, play it (audio only)
            const audioEl = document.createElement('audio');
            audioEl.srcObject = stream;
            audioEl.autoplay = true;
            audioEl.id = `audio-${remoteSocketId}`;
            
            // Hidden audio elements can be appended anywhere, e.g., to the body
            document.body.appendChild(audioEl); 
            console.log(`Playing audio from peer ${remoteSocketId}`);
        };

        // 3. Add local tracks to the connection
        if (localStream) {
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        }

        peerConnections[remoteSocketId] = pc;
        return pc;
    }


    // --- Socket.IO WebRTC Signaling Handlers ---

    // A new user has joined (Initiate a call to them)
    socket.on('vc-user-joined', async (newUserId) => {
        if (!localStream) return; // Only process if we are currently in a call

        const pc = createPeerConnection(newUserId);
        
        // 1. Create and send an Offer (Pioneer role)
        try {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            socket.emit('webrtc-signal', newUserId, { 'offer': pc.localDescription });
        } catch (e) {
             console.error('Error creating offer:', e);
        }
    });

    // A user has left (Clean up their connection)
    socket.on('vc-user-left', (leavingUserId) => {
        if (peerConnections[leavingUserId]) {
            peerConnections[leavingUserId].close();
            delete peerConnections[leavingUserId];
        }
        const audioEl = document.getElementById(`audio-${leavingUserId}`);
        if (audioEl) audioEl.remove();
        console.log(`Removed connection and audio for peer ${leavingUserId}`);
    });

    // Receive WebRTC signals (Offers, Answers, ICE Candidates)
    socket.on('webrtc-signal', async (fromId, signal) => {
        let pc = peerConnections[fromId];
        
        if (signal.offer) {
            // Received an Offer (Responder role)
            if (!localStream) return; // Must be in call to respond

            if (!pc) pc = createPeerConnection(fromId); // Create PC if it doesn't exist

            try {
                await pc.setRemoteDescription(new RTCSessionDescription(signal.offer));
                
                // 1. Create and send an Answer
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                
                socket.emit('webrtc-signal', fromId, { 'answer': pc.localDescription });
            } catch (e) {
                console.error('Error handling offer/answer:', e);
            }
            
        } else if (signal.answer) {
            // Received an Answer (Pioneer role)
            if (pc && pc.signalingState !== 'stable') {
                 try {
                    await pc.setRemoteDescription(new RTCSessionDescription(signal.answer));
                } catch (e) {
                    console.error('Error setting remote description for answer:', e);
                }
            }
        } else if (signal['ice-candidate']) {
            // Received an ICE Candidate
            if (pc) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(signal['ice-candidate']));
                } catch (e) {
                    // Ignore error if candidate is invalid or connection is closed
                    // console.error('Error adding received ICE candidate:', e); 
                }
            }
        }
    });

    // --- Socket.IO VC User List Update ---

    socket.on('vc-user-list-update', (users) => {
        vcUserList.innerHTML = '';
        users.forEach(user => {
            const li = document.createElement('li');
            li.textContent = `üü¢ ${user}`; 
            vcUserList.appendChild(li);
        });
    });

    updateVcControls(false); // Initialize controls state
    
</script>


</body>
</html>
