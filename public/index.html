<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>The C&C Corp chat</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

<div id="app-split-container">
    
    <div id="whiteboard-panel">
        <div id="wb-toolbar">
            <input type="color" id="wb-color" value="#ffffff" title="Brush Color">
            <input type="range" id="wb-size" min="1" max="20" value="3" title="Brush Size">
            <button id="wb-undo-btn">â†© Undo</button>
            <button id="wb-clear-btn">ğŸ—‘ Clear</button>
        </div>
        <canvas id="whiteboard"></canvas>
    </div>

    <div id="main-wrapper">
        <div id="chat-container">
            <div id="username-area">
                <button id="avatar-upload-btn" title="Set Avatar">
                    <img id="current-avatar-preview" src="placeholder-avatar.png" alt="Avatar">
                </button>
                <h3>username:</h3>
                <input type="text" id="username-input" placeholder="whatr we callin ya">
                <button id="set-username-btn">Save</button>
                <div class="dropdown">
                    <button class="dropbtn">âš™ï¸</button>
                    <div class="dropdown-content">
                        <button id="bg-upload-btn">Upload BG</button>
                        <button id="reset-bg-btn">Reset BG</button>
                        <button id="toggle-transparent-btn">Transparent Mode</button>
                        <button id="popout-btn">Popout Chat</button>
                    </div>
                </div>
            </div>

            <div id="online-users-area">
                <h4>whos online:</h4>
                <ul id="online-users-list"></ul>
                <div id="vc-area">
                   <h5>Voice Chat</h5>
                   <ul id="vc-users-list"></ul>
                </div>
            </div>
            
            <div id="messages"></div>

            <div id="typing-indicator"></div>

            <div id="message-input-area">
                <div id="image-preview-area" style="display:none;">
                    <img id="image-preview" src="" alt="Image Preview">
                    <button id="remove-image-btn">X</button>
                </div>
                
                <textarea id="message-input" placeholder="type type type..." rows="1"></textarea>
                <input type="file" id="hidden-file-input" accept="image/*" style="display:none;">
                <input type="file" id="bg-file-input" accept="image/*" style="display:none;">
                
                <button id="send-btn">Send</button>
                <button id="upload-btn" title="Upload Image">+</button>
                <button id="vc-join-btn">ğŸ¤ Join VC</button>
                <button id="vc-mute-btn" style="display:none;">ğŸ”Š Mute</button>
                <button id="cloak-launcher-btn" title="Cloak Launcher">ğŸ•µï¸</button>
            </div>
        </div>
    </div>
</div>

<script>
    const socket = io();
    
    // --- WHITEBOARD LOGIC ---
    const canvas = document.getElementById('whiteboard');
    const ctx = canvas.getContext('2d');
    const wbColor = document.getElementById('wb-color');
    const wbSize = document.getElementById('wb-size');
    let drawing = false;
    let currentX = 0;
    let currentY = 0;

    function resizeCanvas() {
        const parent = canvas.parentElement;
        canvas.width = parent.offsetWidth;
        canvas.height = parent.offsetHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    // Call once after load
    setTimeout(resizeCanvas, 100);

    function drawLine(x0, y0, x1, y1, color, size, emit) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.strokeStyle = color;
        ctx.lineWidth = size;
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.closePath();

        if (!emit) return;
        
        // Normalize coordinates (0 to 1) for varying screen sizes
        const w = canvas.width;
        const h = canvas.height;

        socket.emit('wb-draw', {
            x0: x0 / w, y0: y0 / h,
            x1: x1 / w, y1: y1 / h,
            color: color,
            size: size
        });
    }

    // Mouse Events
    canvas.addEventListener('mousedown', (e) => {
        drawing = true;
        currentX = e.offsetX;
        currentY = e.offsetY;
    });
    canvas.addEventListener('mousemove', (e) => {
        if (!drawing) return;
        drawLine(currentX, currentY, e.offsetX, e.offsetY, wbColor.value, wbSize.value, true);
        currentX = e.offsetX;
        currentY = e.offsetY;
    });
    canvas.addEventListener('mouseup', () => drawing = false);
    canvas.addEventListener('mouseout', () => drawing = false);

    // Touch Events (For Mobile/Tablets)
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault(); 
        const rect = canvas.getBoundingClientRect();
        drawing = true;
        currentX = e.touches[0].clientX - rect.left;
        currentY = e.touches[0].clientY - rect.top;
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!drawing) return;
        const rect = canvas.getBoundingClientRect();
        const newX = e.touches[0].clientX - rect.left;
        const newY = e.touches[0].clientY - rect.top;
        drawLine(currentX, currentY, newX, newY, wbColor.value, wbSize.value, true);
        currentX = newX;
        currentY = newY;
    }, { passive: false });
    canvas.addEventListener('touchend', () => drawing = false);

    // Whiteboard Socket Listeners
    socket.on('wb-draw', (data) => {
        const w = canvas.width;
        const h = canvas.height;
        drawLine(data.x0 * w, data.y0 * h, data.x1 * w, data.y1 * h, data.color, data.size, false);
    });

    socket.on('wb-history', (lines) => {
        lines.forEach(line => {
            const w = canvas.width;
            const h = canvas.height;
            drawLine(line.x0 * w, line.y0 * h, line.x1 * w, line.y1 * h, line.color, line.size, false);
        });
    });

    socket.on('wb-redraw-all', (lines) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        lines.forEach(line => {
            const w = canvas.width;
            const h = canvas.height;
            drawLine(line.x0 * w, line.y0 * h, line.x1 * w, line.y1 * h, line.color, line.size, false);
        });
    });

    document.getElementById('wb-undo-btn').addEventListener('click', () => socket.emit('wb-undo'));
    document.getElementById('wb-clear-btn').addEventListener('click', () => socket.emit('wb-clear'));


    // --- CHAT & UI LOGIC (Existing functionality) ---
    const messagesDiv = document.getElementById('messages');
    const msgInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    
    // ... [Previous Chat Logic truncated for brevity but functionality preserved below] ...

    let myUsername = localStorage.getItem('chat_username') || '';
    if(myUsername) {
        usernameInput.value = myUsername;
        socket.emit('join', myUsername);
        document.getElementById('chat-container').style.display = 'flex';
    }

    setUsernameBtn.addEventListener('click', () => {
        const name = usernameInput.value.trim();
        if(name) {
            myUsername = name;
            localStorage.setItem('chat_username', name);
            socket.emit('join', name);
        }
    });

    sendBtn.addEventListener('click', sendMessage);
    msgInput.addEventListener('keypress', (e) => {
        if(e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    function sendMessage() {
        const text = msgInput.value.trim();
        if(text) {
            socket.emit('chat-message', text);
            msgInput.value = '';
        }
    }

    socket.on('chat-message', (msg) => {
        const div = document.createElement('div');
        div.classList.add('message');
        if (msg.sender === myUsername) div.classList.add('self');
        else if (msg.sender === 'System') div.classList.add('system');
        
        div.innerHTML = `<div class="bubble-content"><strong>${msg.sender}</strong>: ${marked.parse(msg.text)}</div>`;
        messagesDiv.appendChild(div);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    });

    // Handle history
    socket.on('history', (history) => {
        messagesDiv.innerHTML = '';
        history.forEach(msg => {
            const div = document.createElement('div');
            div.classList.add('message');
            if (msg.sender === myUsername) div.classList.add('self');
            else if (msg.sender === 'System') div.classList.add('system');
            
            div.innerHTML = `<div class="bubble-content"><strong>${msg.sender}</strong>: ${marked.parse(msg.text || '')}</div>`;
            messagesDiv.appendChild(div);
        });
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    });

    // Update User Lists
    socket.on('room-users', (data) => {
        const list = document.getElementById('online-users-list');
        list.innerHTML = data.users.map(u => `<li>${u.username}</li>`).join('');
    });

    // --- Background & Transparency Logic ---
    const bgUploadBtn = document.getElementById('bg-upload-btn');
    const bgFileInput = document.getElementById('bg-file-input');
    const resetBgBtn = document.getElementById('reset-bg-btn');
    const transBtn = document.getElementById('toggle-transparent-btn');

    bgUploadBtn.addEventListener('click', () => bgFileInput.click());
    
    bgFileInput.addEventListener('change', () => {
        const file = bgFileInput.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                document.body.style.backgroundImage = `url('${e.target.result}')`;
                localStorage.setItem('custom_bg', e.target.result);
            };
            reader.readAsDataURL(file);
        }
    });

    resetBgBtn.addEventListener('click', () => {
        document.body.style.backgroundImage = '';
        localStorage.removeItem('custom_bg');
    });

    transBtn.addEventListener('click', () => {
        document.body.classList.toggle('transparent-mode');
    });

    // Load saved BG
    const savedBg = localStorage.getItem('custom_bg');
    if(savedBg) document.body.style.backgroundImage = `url('${savedBg}')`;
    
    // Cloak
    document.getElementById('cloak-launcher-btn').addEventListener('click', () => {
        const win = window.open('about:blank', '_blank');
        if(win) {
            win.document.write('<iframe src="https://tuff.speedslicer.dev/files/1_1UT8/WASM/" style="border:0; width:100vw; height:100vh;"></iframe>');
            win.document.close();
        }
    });

</script>
</body>
</html>
