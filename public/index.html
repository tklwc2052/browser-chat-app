<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple Chat App</title>
<link rel="stylesheet" href="new.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="chat-container">
        <div id="username-area">
            <button id="avatar-upload-btn" title="Set Avatar (Click to Upload)">
                <img id="current-avatar-preview" src="placeholder-avatar.png" alt="Avatar">
            </button>
            <h3>username:</h3>
            <input type="text" id="username-input" placeholder="whatr we callin ya">
            <button id="set-username-btn">Save</button>
        </div>

        <div id="online-users-area">
            <h4>whos online:</h4>
            <ul id="online-users-list"></ul>
        </div>
        
        <div id="messages"></div>

        <div id="message-input-area">
            <div id="image-preview-area" style="display:none;">
                <img id="image-preview" src="" alt="Image Preview">
                <button id="remove-image-btn">X</button>
            </div>
            <textarea id="message-input" placeholder="type type type..." rows="1"></textarea>
            <button id="file-upload-btn" title="File Upload (Not implemented)">üìÅ</button>
            <button id="send-button">Send</button>
        </div>
    </div>

    <div id="vc-container">
        <div id="vc-header">
            <h3>Voice Chat</h3>
            <div id="vc-controls">
                <button id="join-vc-btn" class="vc-btn join">Join Voice</button>
                <button id="leave-vc-btn" class="vc-btn leave" disabled>Leave</button>
                <button id="mute-btn" class="vc-btn mute" disabled>Mute</button>
            </div>
        </div>
        <ul id="vc-users-list">
            </ul>
        </div>
    
    <input type="file" id="hidden-file-input" accept="image/*" style="display: none;">

    <button id="launch-custom-window-btn" style="display:none;">Open Popup Mode</button>

</div>

<script>
    const socket = io();

    // --- DOM Elements ---
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const messagesDiv = document.getElementById('messages');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const onlineUsersList = document.getElementById('online-users-list');
    
    // VC Elements
    const vcUsersList = document.getElementById('vc-users-list');
    const joinVCBtn = document.getElementById('join-vc-btn');
    const leaveVCBtn = document.getElementById('leave-vc-btn');
    const muteBtn = document.getElementById('mute-btn');

    // Avatar / Image Elements
    const avatarUploadBtn = document.getElementById('avatar-upload-btn');
    const currentAvatarPreview = document.getElementById('current-avatar-preview');
    const hiddenFileInput = document.getElementById('hidden-file-input');
    const fileUploadBtn = document.getElementById('file-upload-btn');
    const imagePreviewArea = document.getElementById('image-preview-area');
    const imagePreview = document.getElementById('image-preview');
    const removeImageBtn = document.getElementById('remove-image-btn');

    // State
    let myUsername = '';
    let myAvatar = null;
    let pendingImage = null; // Base64 string of image waiting to be sent
    let isUploadingAvatar = false; // Flag to know if file input is for avatar or message
    
    // --- WebRTC State ---
    let localStream = null;
    let isMuted = false;
    const peers = {}; // { socketId: RTCPeerConnection }
    const iceConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' } // Public Google STUN server
        ]
    };

    // --- 1. User & Avatar Logic ---
    
    // Check local storage
    if (localStorage.getItem('chat_username')) {
        myUsername = localStorage.getItem('chat_username');
        usernameInput.value = myUsername;
    }
    if (localStorage.getItem('chat_avatar')) {
        myAvatar = localStorage.getItem('chat_avatar');
        currentAvatarPreview.src = myAvatar;
    }

    setUsernameBtn.addEventListener('click', () => {
        const val = usernameInput.value.trim();
        if (val) {
            myUsername = val;
            localStorage.setItem('chat_username', myUsername);
            socket.emit('set-username', { username: myUsername, avatar: myAvatar });
            
            usernameInput.disabled = true;
            setUsernameBtn.disabled = true;
            avatarUploadBtn.disabled = true; // Lock avatar after join
        }
    });

    // Auto-join if user exists in storage (Optional, but good for refresh)
    // For now we wait for explicit click

    // Avatar Upload Click
    avatarUploadBtn.addEventListener('click', () => {
        if (!usernameInput.disabled) {
            isUploadingAvatar = true;
            hiddenFileInput.click();
        }
    });

    // Message File Upload Click
    fileUploadBtn.addEventListener('click', () => {
        isUploadingAvatar = false;
        hiddenFileInput.click();
    });

    // File Input Change
    hiddenFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (evt) => {
                const result = evt.target.result;
                if (isUploadingAvatar) {
                    myAvatar = result;
                    currentAvatarPreview.src = result;
                    localStorage.setItem('chat_avatar', result);
                } else {
                    // It's a message image
                    pendingImage = result;
                    imagePreview.src = result;
                    imagePreviewArea.style.display = 'flex';
                }
            };
            reader.readAsDataURL(file);
        }
        hiddenFileInput.value = ''; // Reset
    });

    removeImageBtn.addEventListener('click', () => {
        pendingImage = null;
        imagePreviewArea.style.display = 'none';
    });


    // --- 2. Sending Messages ---
    sendButton.addEventListener('click', sendMessage);
    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    function sendMessage() {
        const text = messageInput.value.trim();
        
        // If we have text OR an image, we send
        if ((text || pendingImage) && myUsername) {
            
            // If image exists, we can append it to text as HTML or handle separate logic.
            // Simple approach: Append img tag to text.
            let finalContent = text;
            if (pendingImage) {
                finalContent += `<br><img src="${pendingImage}" class="message-image">`;
            }

            socket.emit('send-message', finalContent);
            
            // Reset
            messageInput.value = '';
            pendingImage = null;
            imagePreviewArea.style.display = 'none';
        }
    }

    // --- 3. Receiving Messages ---
    socket.on('chat-message', (msg) => {
        displayMessage(msg);
    });
    
    socket.on('history', (history) => {
        messagesDiv.innerHTML = '';
        history.forEach(displayMessage);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    });

    function displayMessage(msg) {
        // msg = { text: "...", avatar: "..." }
        // We expect text to contain HTML (from formatMessage)
        
        const div = document.createElement('div');
        div.classList.add('message');

        // Extract raw text to check if it's me
        // Format: "**Name**: Message..."
        // Simple check:
        const isMe = msg.text.startsWith(`**${myUsername}**`);
        if (isMe) div.classList.add('message-self');
        
        // Parse the text part vs sender part logic (simplified for this demo)
        // We will just render innerHTML because server trusted formatted it (mostly)
        
        let contentHtml = msg.text;
        
        // Add avatar if present and not System
        if (msg.avatar) {
             div.innerHTML = `<img src="${msg.avatar}" class="avatar"> <span class="bubble">${contentHtml}</span>`;
        } else {
             // System message or no avatar
             div.innerHTML = `<span class="bubble">${contentHtml}</span>`;
        }
        
        messagesDiv.appendChild(div);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }


    // --- 4. User Lists ---
    socket.on('user-list-update', (users) => {
        onlineUsersList.innerHTML = '';
        users.forEach(u => {
            const li = document.createElement('li');
            li.textContent = u.username;
            onlineUsersList.appendChild(li);
        });
    });

    socket.on('vc-user-list-update', (vcUsers) => {
        vcUsersList.innerHTML = '';
        vcUsers.forEach(u => {
            const li = document.createElement('li');
            li.innerHTML = `${u.isMuted ? 'üîá' : 'üîä'} ${u.username}`;
            vcUsersList.appendChild(li);
        });
    });

    // --- 5. Voice Chat Logic (WebRTC) ---

    // A. Join Voice
    joinVCBtn.addEventListener('click', async () => {
        if (!myUsername) {
            alert("Set username first!");
            return;
        }

        try {
            // 1. Get Microphone stream
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            
            // 2. Enable buttons
            joinVCBtn.disabled = true;
            leaveVCBtn.disabled = false;
            muteBtn.disabled = false;

            // 3. Emit join event
            socket.emit('join-vc');

        } catch (err) {
            console.error("Microphone access denied:", err);
            alert("Could not access microphone. Check permissions.");
        }
    });

    // B. Leave Voice
    leaveVCBtn.addEventListener('click', () => {
        // 1. Stop local tracks
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }

        // 2. Close all peer connections
        Object.keys(peers).forEach(key => {
            peers[key].close();
            delete peers[key];
            
            // Remove audio element
            const audioEl = document.getElementById(`audio-${key}`);
            if (audioEl) audioEl.remove();
        });

        // 3. Update UI
        joinVCBtn.disabled = false;
        leaveVCBtn.disabled = true;
        muteBtn.disabled = true;
        muteBtn.textContent = "Mute";
        isMuted = false;

        // 4. Tell server
        socket.emit('leave-vc');
    });

    // C. Mute Toggle
    muteBtn.addEventListener('click', () => {
        if (localStream) {
            isMuted = !isMuted;
            localStream.getAudioTracks()[0].enabled = !isMuted; // Toggle track
            muteBtn.textContent = isMuted ? "Unmute" : "Mute";
            socket.emit('vc-mute-toggle', isMuted);
        }
    });


    // --- 6. WebRTC Socket Handlers ---

    // Triggered when SOMEONE ELSE joins the VC
    socket.on('vc-user-joined', async (data) => {
        // If we are not in VC, ignore
        if (!localStream) return;
        
        console.log("New user in VC, initiating call to:", data.id);
        const pc = createPeerConnection(data.id);
        
        // Create Offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        
        socket.emit('voice-offer', { to: data.id, offer: offer });
    });

    // Triggered when SOMEONE ELSE leaves
    socket.on('vc-user-left', (data) => {
        if (peers[data.id]) {
            peers[data.id].close();
            delete peers[data.id];
            const audioEl = document.getElementById(`audio-${data.id}`);
            if (audioEl) audioEl.remove();
        }
    });

    // Handle incoming Offer
    socket.on('voice-offer', async ({ from, offer }) => {
        // We received a call
        if (!localStream) return; // Should allow answering? Usually only if in VC.
        
        const pc = createPeerConnection(from);
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        
        socket.emit('voice-answer', { to: from, answer: answer });
    });

    // Handle incoming Answer
    socket.on('voice-answer', async ({ from, answer }) => {
        const pc = peers[from];
        if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
        }
    });

    // Handle incoming Ice Candidate
    socket.on('voice-candidate', async ({ from, candidate }) => {
        const pc = peers[from];
        if (pc) {
            try {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
            } catch (e) {
                console.error("Error adding ice candidate", e);
            }
        }
    });

    // --- 7. Helper: Create Peer Connection ---
    function createPeerConnection(socketId) {
        const pc = new RTCPeerConnection(iceConfig);
        peers[socketId] = pc;

        // Add local stream tracks
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        // ICE Candidate handler
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('voice-candidate', { to: socketId, candidate: event.candidate });
            }
        };

        // Track handler (Incoming Audio)
        pc.ontrack = (event) => {
            console.log("Received remote stream from", socketId);
            const [remoteStream] = event.streams;
            
            let audioEl = document.getElementById(`audio-${socketId}`);
            if (!audioEl) {
                audioEl = document.createElement('audio');
                audioEl.id = `audio-${socketId}`;
                audioEl.autoplay = true;
                document.body.appendChild(audioEl);
            }
            audioEl.srcObject = remoteStream;
        };

        return pc;
    }

</script>
</body>
</html>
