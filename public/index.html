<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Render Chat App</title>
<link rel="stylesheet" href="style.css"> 
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="chat-container">
        <div id="username-area">
            <h3>Username:</h3>
            <input type="text" id="username-input" placeholder="Enter name...">
            <button id="set-username-btn">Join</button>
        </div>

        <div id="online-users-area">
            <h4>Online:</h4>
            <ul id="online-users-list"></ul>
        </div>
        
        <div id="messages"></div>

        <div id="message-input-area">
            <textarea id="message-input" placeholder="Type a message..." rows="1"></textarea>
            <button id="send-button">Send</button>
        </div>
    </div>

    <div id="vc-container">
        <div id="vc-header">
            <h3>Voice Chat</h3>
            <div id="vc-controls">
                <button id="join-vc-btn" class="vc-btn join">Join Voice</button>
                <button id="leave-vc-btn" class="vc-btn leave" disabled>Leave</button>
                <button id="mute-btn" class="vc-btn mute" disabled>Mute</button>
            </div>
        </div>
        <ul id="vc-users-list"></ul>
    </div>

</div>

<script>
    const socket = io(); // Connects automatically on Render

    // --- UI Elements ---
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const messagesDiv = document.getElementById('messages');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const onlineUsersList = document.getElementById('online-users-list');
    
    // VC Elements
    const vcUsersList = document.getElementById('vc-users-list');
    const joinVCBtn = document.getElementById('join-vc-btn');
    const leaveVCBtn = document.getElementById('leave-vc-btn');
    const muteBtn = document.getElementById('mute-btn');

    let myUsername = '';
    
    // --- Voice Chat State ---
    let localStream = null;
    let isMuted = false;
    const peers = {}; // Stores connections: { socketId: RTCPeerConnection }
    
    // STUN Servers allow clients to find each other through NATs/Firewalls.
    const iceConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:global.stun.twilio.com:3478' }
        ]
    };

    // --- 1. Basic Chat Logic ---
    setUsernameBtn.addEventListener('click', () => {
        if (usernameInput.value.trim()) {
            myUsername = usernameInput.value.trim();
            socket.emit('set-username', { username: myUsername, avatar: null });
            usernameInput.disabled = true;
            setUsernameBtn.disabled = true;
        }
    });

    sendButton.addEventListener('click', () => {
        if (messageInput.value.trim() && myUsername) {
            socket.emit('send-message', messageInput.value.trim());
            messageInput.value = '';
        }
    });

    socket.on('chat-message', (msg) => {
        const div = document.createElement('div');
        div.classList.add('message');
        div.innerHTML = msg.text; // Server sends pre-formatted HTML
        messagesDiv.appendChild(div);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    });

    socket.on('history', (history) => {
        messagesDiv.innerHTML = '';
        history.forEach(msg => {
            const div = document.createElement('div');
            div.classList.add('message');
            div.innerHTML = msg;
            messagesDiv.appendChild(div);
        });
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    });

    socket.on('user-list-update', (users) => {
        onlineUsersList.innerHTML = '';
        users.forEach(u => {
            const li = document.createElement('li');
            li.textContent = u.username;
            onlineUsersList.appendChild(li);
        });
    });

    socket.on('vc-user-list-update', (vcUsers) => {
        vcUsersList.innerHTML = '';
        vcUsers.forEach(u => {
            const li = document.createElement('li');
            li.textContent = `${u.isMuted ? 'ðŸ”‡' : 'ðŸ”Š'} ${u.username}`;
            vcUsersList.appendChild(li);
        });
    });

    // --- 2. Voice Chat Logic (WebRTC) ---

    // JOIN VOICE
    joinVCBtn.addEventListener('click', async () => {
        if (!myUsername) { alert("Please join chat first!"); return; }

        try {
            // Request Microphone Access
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            
            // Update UI
            joinVCBtn.disabled = true;
            leaveVCBtn.disabled = false;
            muteBtn.disabled = false;

            // Notify Server
            socket.emit('join-vc');

        } catch (err) {
            console.error(err);
            alert("Microphone access denied or not available.");
        }
    });

    // LEAVE VOICE
    leaveVCBtn.addEventListener('click', () => {
        // Stop Mic
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }

        // Close Connections
        Object.keys(peers).forEach(socketId => {
            peers[socketId].close();
            delete peers[socketId];
            removeAudioElement(socketId);
        });

        // Update UI
        joinVCBtn.disabled = false;
        leaveVCBtn.disabled = true;
        muteBtn.disabled = true;
        muteBtn.textContent = "Mute";
        isMuted = false;

        socket.emit('leave-vc');
    });

    // MUTE TOGGLE
    muteBtn.addEventListener('click', () => {
        if (localStream) {
            isMuted = !isMuted;
            localStream.getAudioTracks()[0].enabled = !isMuted;
            muteBtn.textContent = isMuted ? "Unmute" : "Mute";
            socket.emit('vc-mute-toggle', isMuted);
        }
    });

    // --- 3. WebRTC Signaling Handling ---

    // A new user joined. We (existing users) initiate the call.
    socket.on('vc-user-joined', async (data) => {
        if (!localStream) return; // We aren't in VC, ignore.

        console.log(`User ${data.id} joined. Calling...`);
        const pc = createPeerConnection(data.id);
        
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        
        socket.emit('voice-offer', { to: data.id, offer: offer });
    });

    // Someone left. Cleanup.
    socket.on('vc-user-left', (data) => {
        if (peers[data.id]) {
            peers[data.id].close();
            delete peers[data.id];
            removeAudioElement(data.id);
        }
    });

    // Receive Offer (from an existing user)
    socket.on('voice-offer', async ({ from, offer }) => {
        if (!localStream) return; // Safety check

        const pc = createPeerConnection(from);
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        
        socket.emit('voice-answer', { to: from, answer: answer });
    });

    // Receive Answer
    socket.on('voice-answer', async ({ from, answer }) => {
        const pc = peers[from];
        if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
        }
    });

    // Receive ICE Candidate
    socket.on('voice-candidate', async ({ from, candidate }) => {
        const pc = peers[from];
        if (pc) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
        }
    });

    // --- 4. WebRTC Helper Functions ---

    function createPeerConnection(socketId) {
        const pc = new RTCPeerConnection(iceConfig);
        peers[socketId] = pc;

        // 1. Add Local Audio Tracks
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        // 2. Handle ICE Candidates
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('voice-candidate', { to: socketId, candidate: event.candidate });
            }
        };

        // 3. Handle Incoming Stream (Remote Audio)
        pc.ontrack = (event) => {
            console.log("Audio stream received from", socketId);
            const [remoteStream] = event.streams;
            
            let audioEl = document.getElementById(`audio-${socketId}`);
            if (!audioEl) {
                audioEl = document.createElement('audio');
                audioEl.id = `audio-${socketId}`;
                audioEl.autoplay = true;
                document.body.appendChild(audioEl);
            }
            audioEl.srcObject = remoteStream;
        };

        return pc;
    }

    function removeAudioElement(socketId) {
        const el = document.getElementById(`audio-${socketId}`);
        if (el) el.remove();
    }

</script>
</body>
</html>
