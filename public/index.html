<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple Chat App</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="chat-container">
        <div id="username-area">
            <button id="avatar-upload-btn" title="Set Avatar (Click to Upload)">
                <img id="current-avatar-preview" src="placeholder-avatar.png" alt="Avatar">
            </button>
            <h3>username:</h3>
            <input type="text" id="username-input" placeholder="whatr we callin ya">
            <button id="set-username-btn">Save</button>
        </div>

        <div id="online-users-area">
            <h4>whos online:</h4>
            <ul id="online-users-list">
            </ul>
        </div>
        
        <div id="messages">
        </div>

        <div id="message-input-area">
            <div id="image-preview-area" style="display:none;">
                <img id="image-preview" src="" alt="Image Preview">
                <button id="remove-image-btn">X</button>
            </div>
            <textarea id="message-input" placeholder="type type type..." rows="1"></textarea>
            <button id="file-upload-btn" title="File Upload (Not implemented)">
                üìÅ
            </button>
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <div id="right-panel">
        <h4 class="panel-title">other stuff</h4>
        <button id="launch-custom-window-btn" class="panel-btn">resizable window</button>
        <p class="panel-hint">for a dedicated status/chat window.</p>

        <h4 class="panel-title">voice chat</h4>
        <button id="vc-btn-join" class="panel-btn">Join Call</button>
        <button id="vc-btn-mute" class="panel-btn" style="display: none;">Mute</button>
        <ul id="vc-user-list">
        </ul>
        <div id="audio-container" style="display:none;"></div>
    </div>
    
</div>

<script>
    // --- 0. Popup Mode Check ---
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'popup') {
        const mainWrapper = document.getElementById('main-wrapper');
        const rightPanel = document.getElementById('right-panel');
        const chatContainer = document.getElementById('chat-container');
        const messageInputArea = document.getElementById('message-input-area');
        const fileUploadBtn = document.getElementById('file-upload-btn');
        const sendButton = document.getElementById('send-button');

        if (mainWrapper) { mainWrapper.style.gap = '0'; mainWrapper.style.maxWidth = '150px'; }
        if (rightPanel) { rightPanel.style.display = 'none'; }
        if (chatContainer) { chatContainer.style.maxWidth = '100%'; }
        if (messageInputArea) { messageInputArea.style.flexDirection = 'column'; messageInputArea.style.gap = '5px'; }
        if (fileUploadBtn) { fileUploadBtn.style.width = '100%'; }
        if (sendButton) { sendButton.style.width = '100%'; }
    }

    const socket = io();

    // --- DOM Elements ---
    const messagesDiv = document.getElementById('messages');
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const onlineUsersList = document.getElementById('online-users-list');
    const launchCustomWindowBtn = document.getElementById('launch-custom-window-btn');
    const avatarUploadBtn = document.getElementById('avatar-upload-btn');
    const currentAvatarPreview = document.getElementById('current-avatar-preview');
    const vcBtnJoin = document.getElementById('vc-btn-join');
    const vcBtnMute = document.getElementById('vc-btn-mute');
    const vcUserList = document.getElementById('vc-user-list');
    const audioContainer = document.getElementById('audio-container');


    let currentUsername = '';
    let currentAvatarBase64 = ''; 
    let lastMessageSender = ''; 
    let lastMessageTime = 0; 
    
    // --- WebRTC State Variables ---
    let localStream = null;
    let peers = {}; 
    let isInVC = false;

    // --- NEW: Audio Analysis Context (Global) ---
    // Browsers limit number of contexts, so we create one and reuse it.
    let audioCtx; 

    const rtcConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };

    // --- 1. Utility: Formatting ---
    function parseFormatting(text) {
        let formattedText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        formattedText = formattedText.replace(/~~(.*?)~~/g, '<del>$1</del>');
        formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        formattedText = formattedText.replace(/__(.*?)\b__/g, '<u>$1</u>'); 
        formattedText = formattedText.replace(/\*(.*?)\*/g, '<em>$1</em>');
        formattedText = formattedText.replace(/&lt;del&gt;/g, '<del>').replace(/&lt;\/del&gt;/g, '</del>');
        formattedText = formattedText.replace(/&lt;strong&gt;/g, '<strong>').replace(/&lt;\/strong&gt;/g, '</strong>');
        formattedText = formattedText.replace(/&lt;u&gt;/g, '<u>').replace(/&lt;\/u&gt;/g, '</u>');
        formattedText = formattedText.replace(/&lt;em&gt;/g, '<em>').replace(/&lt;\/em&gt;/g, '</em>');
        return formattedText;
    }

    // --- 2. Avatar Selection ---
    avatarUploadBtn.addEventListener('click', () => {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onloadend = () => {
                    currentAvatarBase64 = reader.result;
                    currentAvatarPreview.src = currentAvatarBase64; 
                    if (currentUsername) setUsername(currentUsername); 
                    localStorage.setItem('chatAvatar', currentAvatarBase64);
                };
                reader.readAsDataURL(file);
            }
        });
        fileInput.click();
    });

    // --- 3. Username Handling ---
    document.addEventListener('DOMContentLoaded', () => {
        const storedUsername = localStorage.getItem('chatUsername');
        const storedAvatar = localStorage.getItem('chatAvatar');

        if (storedAvatar) {
            currentAvatarBase64 = storedAvatar;
            currentAvatarPreview.src = storedAvatar;
        } else {
            currentAvatarPreview.src = 'placeholder-avatar.png';
        }

        if (storedUsername) {
            usernameInput.value = storedUsername;
            setUsername(storedUsername);
        }
    });

    setUsernameBtn.addEventListener('click', () => {
        const username = usernameInput.value.trim();
        if (username) {
            localStorage.setItem('chatUsername', username);
            if (currentAvatarBase64) localStorage.setItem('chatAvatar', currentAvatarBase64);
            setUsername(username);
        }
    });
    
    function setUsername(username) {
        currentUsername = username;
        socket.emit('set-username', { username: currentUsername, avatar: currentAvatarBase64 || 'placeholder-avatar.png' }); 
        usernameInput.disabled = true;
        setUsernameBtn.disabled = true;
        usernameInput.placeholder = 'Username set!';
        messageInput.focus();
    }

    // --- 4. Message Sending ---
    function sendMessage() {
        let msg = messageInput.value.trim();
        if (!msg || !currentUsername) return; 
        socket.emit('chat-message', msg);
        messageInput.value = '';
    }

    sendButton.addEventListener('click', sendMessage);

    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // --- 5. Message Display ---
    function displayMessage(messageObject) {
        let formattedMessage, messageAvatar, sender;
        
        if (typeof messageObject === 'string' || messageObject.avatar === null) {
            formattedMessage = messageObject.text || messageObject; 
            messageAvatar = null; sender = null;
        } else {
            formattedMessage = messageObject.text;
            messageAvatar = messageObject.avatar; sender = messageObject.sender;
        }

        const messageEl = document.createElement('div');
        messageEl.classList.add('message');

        const fullMatch = formattedMessage.match(/\*\*(.*?)\*\*: (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);

        // System/Announcement
        if (!fullMatch) {
            const systemMatch = formattedMessage.match(/\*\*(.*?)\*\* (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);
            lastMessageTime = 0; lastMessageSender = ''; 

            if (systemMatch) {
                messageEl.classList.add('system-message');
                const systemText = systemMatch[2];
                if (systemText.startsWith('**[PM from') || systemText.startsWith('**[PM to')) {
                    messageEl.classList.add('private-message');
                    messageEl.innerHTML = parseFormatting(`<u>${systemText.replace(/\*\*(.*?)\*\*/, '$1')}</u>`); 
                    messagesDiv.appendChild(messageEl);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    return; 
                }
                messageEl.innerHTML = parseFormatting(systemText);
                messagesDiv.appendChild(messageEl);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                return;
            }
            messageEl.classList.add('system-message');
            messageEl.innerHTML = parseFormatting(formattedMessage);
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return;
        }
        
        const extractedSender = fullMatch[1];
        const messageText = fullMatch[2];
        const timeString = fullMatch[3]; 

        const finalSender = sender || extractedSender;
        const finalAvatar = messageAvatar || 'placeholder-avatar.png'; 
        const isUserMessage = (finalSender === currentUsername);
        let showAvatar = true;
        let showUsername = true; 

        let currentTimeInMinutes = 0;
        const timeParts = timeString.match(/(\d{1,2}):(\d{2}) (AM|PM)/);
        if (timeParts) {
            let hours = parseInt(timeParts[1]);
            const minutes = parseInt(timeParts[2]);
            const isPM = timeParts[3] === 'PM';
            if (isPM && hours !== 12) hours += 12;
            if (!isPM && hours === 12) hours = 0;
            currentTimeInMinutes = hours * 60 + minutes;
        }

        if (isUserMessage) {
            messageEl.classList.add('user-message');
            showUsername = false; 
        } else {
            messageEl.classList.add('other-message');
        }

        if ((lastMessageSender === finalSender) && (currentTimeInMinutes - lastMessageTime) < 1) {
            showAvatar = false; showUsername = false; 
            messageEl.classList.add('grouped-message');
            const previousMessageEl = messagesDiv.lastChild;
            if (previousMessageEl && !previousMessageEl.classList.contains('system-message')) {
                const prevWrapper = previousMessageEl.querySelector('.message-content-wrapper');
                if (prevWrapper) {
                    const prevTime = prevWrapper.querySelector('.message-time');
                    if (prevTime) prevTime.remove();
                }
            }
        } 

        lastMessageSender = finalSender;
        lastMessageTime = currentTimeInMinutes;
        
        if (!isUserMessage) {
            if (showAvatar) {
                const avatarImg = document.createElement('img');
                avatarImg.classList.add('avatar');
                avatarImg.src = finalAvatar;
                messageEl.appendChild(avatarImg);
            } else {
                const spacer = document.createElement('div');
                spacer.classList.add('avatar-spacer');
                messageEl.appendChild(spacer);
            }
        }
        
        const contentArea = document.createElement('div');
        contentArea.classList.add('message-content-area');
        
        if (showUsername && !isUserMessage) {
            const usernameDiv = document.createElement('div');
            usernameDiv.classList.add('message-username');
            usernameDiv.innerHTML = `<strong>${finalSender}</strong>:`;
            contentArea.appendChild(usernameDiv);
        }

        const contentWrapper = document.createElement('div');
        contentWrapper.classList.add('message-content-wrapper');
        
        const bubbleContent = document.createElement('span');
        bubbleContent.classList.add('bubble-content');
        bubbleContent.innerHTML = parseFormatting(messageText);
        contentWrapper.appendChild(bubbleContent); 
        
        const timeSpan = document.createElement('span');
        timeSpan.classList.add('message-time');
        timeSpan.textContent = timeString; 
        contentWrapper.appendChild(timeSpan); 
        
        contentArea.appendChild(contentWrapper);
        messageEl.appendChild(contentArea);
        
        messagesDiv.appendChild(messageEl);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }


    // ======================================================
    // --- 6. VOICE CHAT LOGIC (WEBRTC + VISUALS) ---
    // ======================================================
    
    // --- Audio Visualization Helper ---
    function attachSpeakingDetector(stream, userId) {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Create an analyser node
        const source = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        source.connect(analyser);

        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        // Check volume periodically
        function checkVolume() {
            // Stop loop if we left VC
            if (!isInVC) return;

            analyser.getByteFrequencyData(dataArray);
            
            // Calculate average volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const average = sum / dataArray.length;

            // Threshold for "speaking" (adjustable)
            const isSpeaking = average > 10; 

            // Find the UI element for this user
            // Note: Since ID is passed from server, we need to match it
            const userLi = document.getElementById(`vc-user-${userId}`);
            
            if (userLi) {
                if (isSpeaking) {
                    userLi.classList.add('speaking');
                } else {
                    userLi.classList.remove('speaking');
                }
            }

            // Loop smoothly
            requestAnimationFrame(checkVolume);
        }

        checkVolume();
    }

    async function startVC() {
        try {
            // 1. Get Microphone Access
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            
            // 2. Initialize Audio Context (needed for user gesture policies)
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();

            // 3. Attach detector to MY OWN stream (so I see myself glow)
            // We use a temporary ID 'local' first, but we need the socket ID.
            // Fortunately, socket.id is available globally from the library.
            attachSpeakingDetector(localStream, socket.id);

            // 4. Update UI
            isInVC = true;
            vcBtnJoin.textContent = 'Leave Call';
            vcBtnJoin.style.backgroundColor = 'var(--color-vc-red)';
            vcBtnMute.style.display = 'block';
            vcBtnMute.textContent = 'Mute';
            vcBtnMute.classList.remove('active');
            
            // 5. Notify Server
            socket.emit('vc-join', true);

        } catch (err) {
            console.error('Error accessing microphone:', err);
            alert('Could not access microphone. Ensure permissions are granted.');
        }
    }

    function leaveVC() {
        socket.emit('vc-join', false);
        
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }

        Object.keys(peers).forEach(key => {
            peers[key].close();
            delete peers[key];
        });
        
        audioContainer.innerHTML = '';
        if(audioCtx) audioCtx.close(); 
        audioCtx = null; // Reset context

        isInVC = false;
        vcBtnJoin.textContent = 'Join Call';
        vcBtnJoin.style.backgroundColor = 'var(--color-accent-blue)';
        vcBtnMute.style.display = 'none';
    }

    // --- WebRTC Connection ---
    function createPeerConnection(targetId, initiator) {
        if (peers[targetId]) return;

        const peer = new RTCPeerConnection(rtcConfig);
        peers[targetId] = peer;

        if (localStream) {
            localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
        }

        // Receive Remote Stream
        peer.ontrack = (event) => {
            // 1. Play Audio
            let audioEl = document.getElementById(`audio-${targetId}`);
            if (!audioEl) {
                audioEl = document.createElement('audio');
                audioEl.id = `audio-${targetId}`;
                audioEl.autoplay = true;
                audioContainer.appendChild(audioEl);
            }
            audioEl.srcObject = event.streams[0];

            // 2. Attach Visual Detector to Remote Stream
            attachSpeakingDetector(event.streams[0], targetId);
        };

        peer.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('signal', {
                    target: targetId,
                    signal: { type: 'candidate', candidate: event.candidate }
                });
            }
        };

        if (initiator) {
            peer.createOffer()
                .then(offer => peer.setLocalDescription(offer))
                .then(() => {
                    socket.emit('signal', {
                        target: targetId,
                        signal: { type: 'offer', sdp: peer.localDescription }
                    });
                })
                .catch(err => console.error('Error creating offer:', err));
        }
        
        return peer;
    }

    // --- Socket Listeners (VC) ---
    socket.on('vc-user-joined', (newUserId) => {
        if (isInVC) createPeerConnection(newUserId, true);
    });

    socket.on('vc-user-left', (userId) => {
        if (peers[userId]) {
            peers[userId].close();
            delete peers[userId];
        }
        const audioEl = document.getElementById(`audio-${userId}`);
        if (audioEl) audioEl.remove();
    });

    socket.on('signal', async ({ sender, signal }) => {
        if (!isInVC) return;
        let peer = peers[sender];
        if (!peer) peer = createPeerConnection(sender, false);

        if (signal.type === 'offer') {
            await peer.setRemoteDescription(new RTCSessionDescription(signal.sdp));
            const answer = await peer.createAnswer();
            await peer.setLocalDescription(answer);
            socket.emit('signal', { target: sender, signal: { type: 'answer', sdp: answer } });
        } 
        else if (signal.type === 'answer') {
            await peer.setRemoteDescription(new RTCSessionDescription(signal.sdp));
        } 
        else if (signal.type === 'candidate') {
            try { await peer.addIceCandidate(new RTCIceCandidate(signal.candidate)); } catch (e) {}
        }
    });

    vcBtnJoin.addEventListener('click', () => {
        if (!currentUsername) { alert("Please set a username first."); return; }
        if (!isInVC) startVC();
        else leaveVC();
    });

    vcBtnMute.addEventListener('click', () => {
        if (!localStream) return;
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled; 
            const isMuted = !audioTrack.enabled;
            vcBtnMute.textContent = isMuted ? 'Unmute' : 'Mute';
            if (isMuted) vcBtnMute.classList.add('active');
            else vcBtnMute.classList.remove('active');
            socket.emit('vc-mute-toggle', isMuted);
        }
    });

    // --- VC List Update (With IDs for targeting) ---
    socket.on('vc-user-list-update', (vcUsers) => {
        vcUserList.innerHTML = '';
        vcUsers.forEach(userData => {
            const li = document.createElement('li');
            
            // IMPORTANT: Assign ID so we can find it for audio visualization
            li.id = `vc-user-${userData.id}`;

            const listAvatar = document.createElement('img');
            listAvatar.classList.add('avatar', 'list-avatar');
            listAvatar.src = userData.avatar || 'placeholder-avatar.png'; 
            li.appendChild(listAvatar);

            li.appendChild(document.createTextNode(userData.username));
            
            if (userData.isMuted) {
                const muteStatus = document.createElement('span');
                muteStatus.textContent = ' üîá';
                muteStatus.style.color = 'var(--color-vc-red)';
                li.appendChild(muteStatus);
            }
            
            if (userData.username === currentUsername) {
                li.style.fontWeight = 'bold';
            }
            
            vcUserList.appendChild(li);
        });
    });


    // --- 7. General Updates ---
    socket.on('history', (history) => {
        lastMessageTime = 0; lastMessageSender = ''; 
        messagesDiv.innerHTML = ''; 
        history.forEach(msg => displayMessage(msg));
        messagesDiv.scrollTop = messagesDiv.scrollHeight; 
    });

    socket.on('chat-message', (msg) => displayMessage(msg));
    socket.on('clear-chat', () => messagesDiv.innerHTML = '');

    socket.on('user-list-update', (users) => {
        onlineUsersList.innerHTML = '';
        users.forEach(userData => {
            const li = document.createElement('li');
            const listAvatar = document.createElement('img');
            listAvatar.classList.add('avatar', 'list-avatar');
            listAvatar.src = userData.avatar || 'placeholder-avatar.png'; 
            li.appendChild(listAvatar);
            li.appendChild(document.createTextNode(userData.username));
            onlineUsersList.appendChild(li);
        });
    });

    if (launchCustomWindowBtn) {
         launchCustomWindowBtn.addEventListener('click', () => {
            const currentUrl = window.location.href.split('?')[0]; 
            const newUrl = `${currentUrl}?mode=popup`; 
            window.open(newUrl, '_blank', 'width=200,height=700,resizable=yes');
        });
    }
</script>
</body>
</html>
