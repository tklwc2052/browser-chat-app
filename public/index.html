<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The C&C Corp chat</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="dm-sidebar">
        <div id="dm-header">C&C Corp</div>
        <div id="dm-list">
            <div class="dm-user-card active" onclick="switchChannel(null)">
                <div class="dm-avatar-wrapper">
                    <div style="width:40px; height:40px; background:#5865F2; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white;">#</div>
                </div>
                <div class="dm-username">General Chat</div>
            </div>
        </div>
        
        <div id="username-area">
            <div id="username-controls">
                <img id="current-avatar-preview" src="placeholder-avatar.png">
                <span id="current-username-display">Loading...</span>
            </div>
            <button id="open-profile-btn">⚙️</button>
        </div>
    </div>

    <div id="chat-container">
        <div id="messages"></div>

        <div id="message-input-area">
            <div id="reply-bar" style="display:none;">
                <span id="replying-to-text">Replying...</span>
                <button id="cancel-reply-btn">x</button>
            </div>
            <div id="image-preview-area" style="display:none;">
                <img id="image-preview" src="">
                <button id="remove-image-btn">X</button>
            </div>
            <div id="input-row">
                <button id="file-upload-btn">➕</button>
                <input type="file" id="file-input" accept="image/*" style="display: none;">
                <input type="text" id="message-input" placeholder="Message #general" autocomplete="off">
                <button id="send-button">➤</button>
            </div>
        </div>
    </div>

    <div id="right-panel">
        <div class="panel-top-group">
            <div class="panel-title">Voice Chat</div>
            <button id="vc-btn-join" class="panel-btn">Join Voice</button>
            <ul id="vc-user-list"></ul>
        </div>
        <div class="panel-bottom-group">
            <div class="panel-title">Online</div>
            <div id="online-user-list"></div>
        </div>
    </div>
</div>

<div id="ctx-menu">
    <div id="ctx-reply">Reply</div>
    <div id="ctx-edit">Edit Message</div>
    <div id="ctx-delete" style="color:#ff4444;">Delete Message</div>
</div>

<div id="username-modal" style="display:flex; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999; justify-content:center; align-items:center;">
    <div style="background:#2f3136; padding:20px; border-radius:8px; text-align:center;">
        <h3>Enter Username</h3>
        <input type="text" id="username-input-modal" style="padding:10px;" placeholder="Username">
        <button id="username-submit-btn" style="padding:10px 20px;">Join</button>
    </div>
</div>

<script>
    const socket = io();
    let myUsername = localStorage.getItem('simplechat_username');
    let currentDMTarget = null;
    let replyToMsg = null;
    let imageToUpload = null;
    
    // Voice Chat State
    let localStream = null;
    let peers = {}; 
    let isVcJoined = false;
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    
    // --- SETUP ---
    const messagesDiv = document.getElementById('messages');
    const msgInput = document.getElementById('message-input');
    const ctxMenu = document.getElementById('ctx-menu');
    
    if(!myUsername) document.getElementById('username-modal').style.display = 'flex';
    else socket.emit('set-username', { username: myUsername });

    document.getElementById('username-submit-btn').onclick = () => {
        const val = document.getElementById('username-input-modal').value.trim();
        if(val) {
            myUsername = val;
            localStorage.setItem('simplechat_username', val);
            socket.emit('set-username', { username: val });
            document.getElementById('username-modal').style.display = 'none';
        }
    };

    document.getElementById('open-profile-btn').onclick = () => window.location.href = '/profile';

    socket.on('profile-info', (data) => {
        document.getElementById('current-username-display').innerText = data.displayName || data.username;
        document.getElementById('current-avatar-preview').src = data.avatar || 'placeholder-avatar.png';
        if(data.customBackground) document.body.style.backgroundImage = `url('${data.customBackground}')`;
    });

    // --- CHANNEL SWITCHING ---
    window.switchChannel = (target) => {
        currentDMTarget = target;
        document.querySelectorAll('.dm-user-card').forEach(el => el.classList.remove('active'));
        
        // Reset message view (simple clear for now to avoid confusion)
        messagesDiv.innerHTML = '';
        socket.emit('request-history-refresh'); // Optional: In a full app we'd reload relevant history

        if(target) {
            msgInput.placeholder = `Message @${target}`;
            msgInput.style.backgroundColor = '#3c3847';
        } else {
            document.querySelector('.dm-user-card').classList.add('active'); 
            msgInput.placeholder = "Message #general";
            msgInput.style.backgroundColor = '';
            // Reload general history locally if stored, or just wait for new msgs
            // For this simple version, we just let new messages come in
            const motd = document.createElement('div');
            motd.className = 'motd-message'; motd.innerText = "Switched to General"; messagesDiv.appendChild(motd);
        }
    };

    socket.on('sidebar-user-list', (list) => {
        const dmList = document.getElementById('dm-list');
        while(dmList.children.length > 1) dmList.removeChild(dmList.lastChild);
        
        list.forEach(u => {
            if(u.username === myUsername) return;
            const div = document.createElement('div');
            div.className = 'dm-user-card';
            div.innerHTML = `<div class="dm-avatar-wrapper"><img src="${u.avatar || 'placeholder-avatar.png'}"><div class="status-bubble ${u.online?'status-online':'status-offline'}"></div></div><div class="dm-username">${u.displayName}</div>`;
            div.onclick = (e) => {
                // simple visual toggle
                document.querySelectorAll('.dm-user-card').forEach(x => x.classList.remove('active'));
                div.classList.add('active');
                switchChannel(u.username);
            };
            dmList.appendChild(div);
        });
    });

    // --- MESSAGING ---
    function sendMessage() {
        const text = msgInput.value.trim();
        if ((!text && !imageToUpload)) return;
        
        socket.emit('chat-message', {
            text, image: imageToUpload, replyTo: replyToMsg, target: currentDMTarget
        });
        
        msgInput.value = '';
        imageToUpload = null; replyToMsg = null;
        document.getElementById('image-preview-area').style.display = 'none';
        document.getElementById('reply-bar').style.display = 'none';
    }
    
    document.getElementById('send-button').onclick = sendMessage;
    msgInput.addEventListener('keypress', (e) => { if(e.key==='Enter') sendMessage(); });

    socket.on('chat-message', (msg) => {
        // --- FILTER LOGIC ---
        // If we are in General, only show General messages
        if (currentDMTarget === null) {
            if (msg.type === 'pm') return; // Hide PMs from General view
        } 
        // If we are in a DM, only show DMs with THAT person
        else {
            if (msg.type !== 'pm') return; // Hide General messages from DM view
            // Only show if it involves me and the target
            const isWithTarget = (msg.sender === currentDMTarget) || (msg.sender === myUsername && currentDMTarget);
            if (!isWithTarget) return; 
        }

        const div = document.createElement('div');
        div.className = `message ${msg.sender === myUsername ? 'user-message' : 'other-message'}`;
        div.id = `msg-${msg.id}`;
        if (msg.type === 'pm') div.style.borderLeft = "2px solid #9b59b6"; 

        const contentHtml = `
            <div class="bubble-content">
                ${msg.replyTo ? `<div class="reply-preview">Replying to: ${msg.replyTo.text.substring(0,20)}...</div>` : ''}
                ${msg.image ? `<img src="${msg.image}" class="message-image" onclick="window.open('${msg.image}')">` : ''}
                <div style="font-size:0.75em; font-weight:bold; margin-bottom:2px; color:${msg.type==='pm'?'#d09ae6':'#888'}">${msg.senderDisplayName}</div>
                <div class="msg-text">${msg.text}${msg.isEdited?' <span style="font-size:0.7em;color:#aaa">(edited)</span>':''}</div>
            </div>`;
            
        const avatarHtml = `<img class="message-avatar" src="${msg.avatar}">`;
        div.innerHTML = msg.sender === myUsername ? (contentHtml + avatarHtml) : (avatarHtml + contentHtml);
        
        div.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            ctxTargetMsg = msg;
            ctxMenu.style.display = 'block';
            ctxMenu.style.left = e.pageX + 'px';
            ctxMenu.style.top = e.pageY + 'px';
            document.getElementById('ctx-edit').style.display = (msg.sender === myUsername) ? 'block' : 'none';
            document.getElementById('ctx-delete').style.display = (msg.sender === myUsername) ? 'block' : 'none';
        });

        messagesDiv.appendChild(div);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    });

    // History Loader
    socket.on('history', (history) => {
        if(currentDMTarget === null) {
            history.forEach(msg => {
                // Only append general messages to history on load
                if(msg.type !== 'pm') {
                    // Reuse the append logic by manually calling the listener or extracting it
                    // For simplicity, we just trigger the event handler logic manually or rely on socket.io
                    // Copying basic append logic here for startup:
                    const div = document.createElement('div');
                    div.className = `message ${msg.sender === myUsername ? 'user-message' : 'other-message'}`;
                    div.id = `msg-${msg.id}`;
                    div.innerHTML = `<img class="message-avatar" src="${msg.avatar}"><div class="bubble-content"><div style="font-size:0.75em;color:#888;font-weight:bold">${msg.senderDisplayName}</div><div class="msg-text">${msg.text}</div></div>`;
                    if(msg.sender === myUsername) div.appendChild(div.firstChild); // Swap
                    messagesDiv.appendChild(div);
                }
            });
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
    });

    // --- CONTEXT MENU ACTIONS ---
    let ctxTargetMsg = null;
    document.addEventListener('click', () => ctxMenu.style.display = 'none');
    
    document.getElementById('ctx-delete').onclick = () => socket.emit('delete-message', ctxTargetMsg.id);
    document.getElementById('ctx-edit').onclick = () => {
        const newText = prompt("Edit message:", ctxTargetMsg.text);
        if(newText) socket.emit('edit-message', { id: ctxTargetMsg.id, newText });
    };
    document.getElementById('ctx-reply').onclick = () => {
        replyToMsg = ctxTargetMsg;
        document.getElementById('reply-bar').style.display = 'flex';
        document.getElementById('replying-to-text').innerText = `Replying to ${ctxTargetMsg.senderDisplayName}`;
    };

    socket.on('message-deleted', (id) => { document.getElementById(`msg-${id}`)?.remove(); });
    socket.on('message-edited', ({id, text}) => {
        const el = document.getElementById(`msg-${id}`);
        if(el) el.querySelector('.msg-text').innerHTML = text + ' <span style="font-size:0.7em;color:#aaa">(edited)</span>';
    });

    // --- FILE UPLOAD ---
    const fileIn = document.getElementById('file-input');
    document.getElementById('file-upload-btn').onclick = () => fileIn.click();
    fileIn.onchange = async () => {
        const f = fileIn.files[0];
        if(!f) return;
        const form = new FormData(); form.append('file', f);
        try {
            const res = await fetch('/upload', { method:'POST', body:form });
            const d = await res.json();
            if(d.url) {
                imageToUpload = d.url;
                document.getElementById('image-preview-area').style.display = 'flex';
                document.getElementById('image-preview').src = d.url;
            }
        } catch(e) { console.error(e); }
    };
    document.getElementById('remove-image-btn').onclick = () => {
        imageToUpload = null; document.getElementById('image-preview-area').style.display = 'none';
    };
    document.getElementById('cancel-reply-btn').onclick = () => {
        replyToMsg = null; document.getElementById('reply-bar').style.display = 'none';
    };

    // --- VOICE CHAT (FIXED) ---
    document.getElementById('vc-btn-join').onclick = () => isVcJoined ? leaveVoice() : joinVoice();

    async function joinVoice() {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            socket.emit('join-vc');
            isVcJoined = true;
            document.getElementById('vc-btn-join').innerText = "Leave Voice";
            document.getElementById('vc-btn-join').style.backgroundColor = '#dc3545';
        } catch(e) { 
            console.error(e);
            alert("Could not access microphone. Ensure site is HTTPS."); 
        }
    }

    function leaveVoice() {
        socket.emit('leave-vc');
        if(localStream) localStream.getTracks().forEach(t => t.stop());
        Object.values(peers).forEach(p => p.pc.close()); // Close stored PCs
        peers = {}; isVcJoined = false;
        document.getElementById('vc-btn-join').innerText = "Join Voice";
        document.getElementById('vc-btn-join').style.backgroundColor = '#23a559';
    }

    socket.on('vc-user-joined', (id) => { if(isVcJoined) createPeer(id, true); });
    socket.on('vc-user-left', (id) => { if(peers[id]) { peers[id].pc.close(); delete peers[id]; } });
    
    // Improved Signal Handler with Queue
    socket.on('signal', async ({ sender, signal }) => {
        if(!isVcJoined) return;
        
        if(!peers[sender]) createPeer(sender, false);
        const pObj = peers[sender];
        const pc = pObj.pc;

        if (signal.candidate) {
            // Queue candidate if remote description isn't set yet
            if (pc.remoteDescription) {
                try { await pc.addIceCandidate(new RTCIceCandidate(signal.candidate)); } catch(e){}
            } else {
                pObj.candidates.push(signal.candidate);
            }
        } else {
            // Handle Offer/Answer
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(signal));
                
                // Process any queued candidates now that description is set
                while(pObj.candidates.length) {
                    await pc.addIceCandidate(new RTCIceCandidate(pObj.candidates.shift()));
                }

                if (signal.type === 'offer') {
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    socket.emit('signal', { target: sender, signal: pc.localDescription });
                }
            } catch(e) { console.error("Signal Error:", e); }
        }
    });

    socket.on('vc-user-list-update', (list) => {
        const ul = document.getElementById('vc-user-list');
        ul.innerHTML = '';
        list.forEach(u => {
            const li = document.createElement('li');
            li.innerText = u.displayName;
            ul.appendChild(li);
        });
    });

    function createPeer(targetId, initiator) {
        const pc = new RTCPeerConnection(rtcConfig);
        // Store PC and a Candidate Queue
        peers[targetId] = { pc: pc, candidates: [] };
        
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
        
        pc.onicecandidate = (e) => {
            if(e.candidate) socket.emit('signal', { target: targetId, signal: { candidate: e.candidate } });
        };
        
        pc.ontrack = (e) => {
            const audio = new Audio();
            audio.srcObject = e.streams[0];
            audio.play();
        };

        if(initiator) {
            pc.createOffer().then(o => {
                pc.setLocalDescription(o);
                socket.emit('signal', { target: targetId, signal: o });
            });
        }
    }
</script>
</body>
</html>
