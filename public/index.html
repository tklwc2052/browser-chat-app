<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple Chat App</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="chat-container">
        <div id="username-area">
            <h3>username:</h3>
            <input type="text" id="username-input" placeholder="whatr we callin ya">
            <button id="set-username-btn">Save</button>
        </div>

        <div id="online-users-area">
            <h4>whos online:</h4>
            <ul id="online-users-list">
                </ul>
        </div>
        
        <div id="messages">
            <div id="drop-zone-overlay" style="display: none;">Drop image here to send</div>
        </div>

        <div id="message-input-area">
            <textarea id="message-input" placeholder="type type type..." rows="1"></textarea>
            
            <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
            
            <button id="file-upload-btn" title="Upload Image/File">
                üìÅ
            </button>
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <div id="right-panel">
        <h4 class="panel-title">other stuff</h4>
        <button id="launch-custom-window-btn" class="panel-btn">resizable window</button>
        <p class="panel-hint"></p>
        
        <h4 class="panel-title">voice chat</h4>
        <div id="vc-area">
            <div id="vc-controls">
                <button id="vc-btn-join" class="panel-btn">Join Call</button>
                <button id="vc-btn-mute" class="vc-btn-mute" style="display: none;">Mute</button>
                <button id="vc-btn-leave" class="vc-btn-leave" style="display: none;">Leave</button>
            </div>
            <ul id="vc-user-list">
                </ul>
        </div>
        </div>
    
</div>

<script>
    // --- 0. Popup Mode Check (CRITICAL: Hides the side panel when URL contains ?mode=popup) ---
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'popup') {
        const mainWrapper = document.getElementById('main-wrapper');
        const rightPanel = document.getElementById('right-panel');
        const chatContainer = document.getElementById('chat-container');
        
        const messageInputArea = document.getElementById('message-input-area');
        const fileUploadBtn = document.getElementById('file-upload-btn');
        const sendButton = document.getElementById('send-button');


        if (mainWrapper) {
            mainWrapper.style.gap = '0';
            mainWrapper.style.maxWidth = '150px'; 
        }
        if (rightPanel) {
            rightPanel.style.display = 'none';
        }
        if (chatContainer) {
            chatContainer.style.maxWidth = '100%';
        }

        if (messageInputArea) {
            messageInputArea.style.flexDirection = 'column';
            messageInputArea.style.gap = '5px';
        }
        if (fileUploadBtn) {
            fileUploadBtn.style.width = '100%';
            fileUploadBtn.style.alignSelf = 'stretch';
        }
        if (sendButton) {
            sendButton.style.width = '100%';
            sendButton.style.alignSelf = 'stretch';
        }
    }
    // ------------------------------------

    const socket = io();

    // --- DOM Elements ---
    const messagesDiv = document.getElementById('messages');
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const onlineUsersList = document.getElementById('online-users-list');
    const launchCustomWindowBtn = document.getElementById('launch-custom-window-btn');
    
    // NEW Media Elements
    const fileUploadBtn = document.getElementById('file-upload-btn');
    const imageUploadInput = document.getElementById('image-upload-input');
    const dropZoneOverlay = document.getElementById('drop-zone-overlay'); // NEW: Drop Zone Overlay

    // VC Elements
    const vcBtnJoin = document.getElementById('vc-btn-join');
    const vcBtnMute = document.getElementById('vc-btn-mute');
    const vcBtnLeave = document.getElementById('vc-btn-leave');
    const vcUserList = document.getElementById('vc-user-list');


    let currentUsername = '';
    let lastUserMessageTime = 0; 
    let lastOtherMessageSender = ''; 
    
    // VC State
    let localStream = null; 
    const peerConnections = {}; 
    let isMuted = false;


    // --- 1. Utility Function to Handle Formatting ---
    function parseFormatting(text) {
        let formattedText = text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        // Order is important: Crossout, Bold, Underline, Italics
        formattedText = formattedText.replace(/~~(.*?)~~/g, '<del>$1</del>');
        formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        formattedText = formattedText.replace(/__(.*?)\b__/g, '<u>$1</u>'); 
        formattedText = formattedText.replace(/\*(.*?)\b/g, '<em>$1</em>'); // Fix: Added \b to * to prevent partial word matching

        // UNSANITIZE the newly added HTML tags for rendering
        formattedText = formattedText.replace(/&lt;del&gt;/g, '<del>').replace(/&lt;\/del&gt;/g, '</del>');
        formattedText = formattedText.replace(/&lt;strong&gt;/g, '<strong>').replace(/&lt;\/strong&gt;/g, '</strong>');
        formattedText = formattedText.replace(/&lt;u&gt;/g, '<u>').replace(/&lt;\/u&gt;/g, '</u>');
        formattedText = formattedText.replace(/&lt;em&gt;/g, '<em>').replace(/&lt;\/em&gt;/g, '</em>');
        
        // This is necessary because the server creates an object, so we only handle image HTML on the client
        formattedText = formattedText.replace(/&lt;div class="image-container"&gt;/g, '<div class="image-container">').replace(/&lt;\/div&gt;/g, '</div>');
        formattedText = formattedText.replace(/&lt;img src="(.*?)" alt="(.*?)"&gt;/g, (match, src, alt) => {
            // Re-sanitize Data URLs only to prevent XSS if possible, but keep the structure
            return `<img src="${src}" alt="${alt}">`;
        });


        return formattedText;
    }

    // --- 2. Username Handling ---
    
    document.addEventListener('DOMContentLoaded', () => {
        const storedUsername = localStorage.getItem('chatUsername');
        if (storedUsername) {
            usernameInput.value = storedUsername;
            setUsername(storedUsername);
        }
    });

    setUsernameBtn.addEventListener('click', () => {
        const username = usernameInput.value.trim();
        if (username) {
            localStorage.setItem('chatUsername', username);
            setUsername(username);
        } else {
            console.warn('Please enter a username.');
        }
    });
    
    function setUsername(username) {
        currentUsername = username;
        socket.emit('set-username', currentUsername); 
        usernameInput.disabled = true;
        setUsernameBtn.disabled = true;
        usernameInput.placeholder = 'Username set!';
        messageInput.focus();
    }

    // --- 3. Message Sending (Text Only) ---

    function sendMessage() {
        let msg = messageInput.value.trim();
        if (!msg || !currentUsername) return; 

        // Send the raw text, the server handles creating the object
        socket.emit('chat-message', msg); 
        messageInput.value = '';
    }

    sendButton.addEventListener('click', sendMessage);

    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    // --- NEW: 3b. Image Upload & Drag/Drop Logic ---

    // Max file size for Base64 Data URLs (500 KB)
    const MAX_FILE_SIZE = 500 * 1024; 

    // Reusable function to handle sending the image
    function processAndSendFile(file) {
        if (!currentUsername) {
            alert('Please set a username before sharing an image.');
            return;
        }
        
        if (!file.type.startsWith('image/')) {
            alert('Only image files are supported.');
            return;
        }

        if (file.size > MAX_FILE_SIZE) { 
             alert(`Image file size (${(file.size / 1024).toFixed(0)} KB) exceeds the ${MAX_FILE_SIZE / 1024} KB limit for embedded chat images. Please choose a smaller image.`);
             return;
        }

        const reader = new FileReader();
        reader.onload = (readerEvent) => {
            const dataUrl = readerEvent.target.result;
            
            // Send the structured media object to the server
            socket.emit('send-media', {
                type: 'image',
                mimeType: file.type,
                content: dataUrl // The Base64 encoded image data
            });
        };
        reader.readAsDataURL(file);
    }

    // 3b.1. Click-to-Upload
    fileUploadBtn.addEventListener('click', () => {
        imageUploadInput.click();
    });

    imageUploadInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            processAndSendFile(file);
        }
        imageUploadInput.value = ''; // Clear the input for next upload
    });
    
    // 3b.2. Drag and Drop Implementation
    messagesDiv.addEventListener('dragover', (e) => {
        e.preventDefault(); 
        dropZoneOverlay.style.display = 'flex'; // Show overlay
    });

    messagesDiv.addEventListener('dragleave', (e) => {
        // Only hide if the mouse moves out of the message area, not just over a child element
        if (e.target === messagesDiv || !messagesDiv.contains(e.relatedTarget)) {
            dropZoneOverlay.style.display = 'none';
        }
    });

    messagesDiv.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZoneOverlay.style.display = 'none'; // Hide overlay
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            // Process the first dropped file
            processAndSendFile(files[0]);
        }
    });
    
    
    // --- 4. Message Display Helper Function (Now accepts a message OBJECT) ---
    function displayMessage(message) { // NEW: Accepts object {id, sender, content, type, time, target}
        const messageEl = document.createElement('div');
        messageEl.classList.add('message');

        // Reset trackers on non-regular message types
        if (message.type !== 'text' && message.type !== 'image') {
             lastUserMessageTime = 0; 
             lastOtherMessageSender = ''; 
        }

        // --- 1. Handle System/Announcement/PM Messages ---
        if (message.type === 'system' || message.type === 'announcement') {
            messageEl.classList.add('system-message');
            messageEl.innerHTML = parseFormatting(message.content);
            
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return;
        }

        if (message.type === 'pm_to' || message.type === 'pm_from') {
             messageEl.classList.add('system-message', 'private-message');
             let prefix = message.type === 'pm_to' ? `PM to ${message.target}` : `PM from ${message.target}`;
             
             // Content format: <u><strong>[Prefix]</strong>: Raw message content</u>
             const pmContent = `<u><strong>[${prefix}]</strong>: ${message.content}</u>`; 
             messageEl.innerHTML = parseFormatting(pmContent); 
             
             messagesDiv.appendChild(messageEl);
             messagesDiv.scrollTop = messagesDiv.scrollHeight;
             return;
        }


        // --- 2. Handle REGULAR Messages (Text & Image) ---

        // Extracted parts for REGULAR messages:
        const sender = message.sender;
        const messageText = message.content;
        const timeString = message.time; 

        const isUserMessage = (sender === currentUsername);
        let showTime = true; 
        let showUsername = true; 

        // --- Calculate Time in Minutes for Grouping ---
        let currentTimeInMinutes = 0;
        const timeParts = timeString.match(/(\d{1,2}):(\d{2}) (AM|PM)/);
        if (timeParts) {
            let hours = parseInt(timeParts[1]);
            const minutes = parseInt(timeParts[2]);
            const isPM = timeParts[3] === 'PM';
            
            if (isPM && hours !== 12) hours += 12;
            if (!isPM && hours === 12) hours = 0;
            currentTimeInMinutes = hours * 60 + minutes;
        }

        // 2b. Set base alignment/username visibility
        if (isUserMessage) {
            messageEl.classList.add('user-message');
            showUsername = false; 
        } else {
            messageEl.classList.add('other-message');
        }


        // 2c. Unified Grouping Logic
        let lastSender = isUserMessage ? currentUsername : lastOtherMessageSender;
        let lastTime = lastUserMessageTime;
        let currentSender = sender;

        const shouldGroup = (lastSender === currentSender) && (currentTimeInMinutes - lastTime) < 1;

        if (shouldGroup) {
            showUsername = false; 
            messageEl.classList.add('grouped-message');

            // === CRITICAL RETROACTIVE FIX (Removes time from the previous message) ===
            const previousMessageEl = messagesDiv.lastChild;
            if (previousMessageEl) {
                const prevContentWrapper = previousMessageEl.querySelector('.message-content-wrapper');
                if (prevContentWrapper) {
                    const prevTimeSpan = prevContentWrapper.querySelector('.message-time');
                    if (prevTimeSpan) {
                        prevTimeSpan.remove(); // DELETE TIME from the previous message
                    }
                }
            }
            // =======================================================================

        } else {
            if (isUserMessage) {
                lastOtherMessageSender = '';
            } else {
                lastUserMessageTime = 0; 
            }
        }

        // 2d. Update Tracking Variables (After Grouping Check)
        if (isUserMessage) {
            lastUserMessageTime = currentTimeInMinutes;
        } else {
            lastOtherMessageSender = currentSender;
            lastUserMessageTime = currentTimeInMinutes; 
        }


        // --- 3. Assemble the Message Structure ---
        
        // 3a. Username 
        if (showUsername && !isUserMessage) {
            const usernameDiv = document.createElement('div');
            usernameDiv.classList.add('message-username');
            usernameDiv.innerHTML = `<strong>${sender}</strong><span class="username-separator">:</span>`;
            messageEl.appendChild(usernameDiv);
        }

        // 3b. Content Wrapper (Bubble + Content + Time)
        const contentWrapper = document.createElement('div');
        contentWrapper.classList.add('message-content-wrapper');
        
        const bubbleContent = document.createElement('span');
        bubbleContent.classList.add('bubble-content');
        
        let contentHtml = '';

        if (message.type === 'text') {
            // Text Message: Parse formatting
            contentHtml = parseFormatting(messageText); 
        } else if (message.type === 'image') {
            // Image Message: Create image tag
            contentHtml = `<div class="image-container"><img src="${messageText}" alt="Image uploaded by ${sender}"></div>`;
            bubbleContent.classList.add('image-bubble-content'); // Add class for styling
        }

        bubbleContent.innerHTML = contentHtml;
        contentWrapper.appendChild(bubbleContent); 
        
        // 3c. Time Content 
        if (showTime) {
            const timeSpan = document.createElement('span');
            timeSpan.classList.add('message-time');
            timeSpan.textContent = timeString; 
            contentWrapper.appendChild(timeSpan); 
        }

        // 4. Assemble the final message element
        messageEl.appendChild(contentWrapper);
        
        messagesDiv.appendChild(messageEl);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }


    // --- 5. Receiving Messages (History and Live) ---
    // history and chat-message now emit/receive message OBJECTS

    socket.on('history', (history) => {
        lastUserMessageTime = 0; 
        lastOtherMessageSender = ''; 
        messagesDiv.innerHTML = ''; 

        history.forEach(msg => {
            displayMessage(msg);
        });
        
        messagesDiv.scrollTop = messagesDiv.scrollHeight; 
    });

    socket.on('chat-message', (messageObject) => { 
        displayMessage(messageObject);
    });

    socket.on('clear-chat', () => {
        messagesDiv.innerHTML = '';
    });

    // --- 6. Online User List Update ---
    
    socket.on('user-list-update', (users) => {
        onlineUsersList.innerHTML = '';
        users.forEach(user => {
            const li = document.createElement('li');
            li.textContent = user;
            onlineUsersList.appendChild(li);
        });
    });

    // --- 7. Launch Custom Window Logic (UPDATED) ---
    if (launchCustomWindowBtn) {
         launchCustomWindowBtn.addEventListener('click', () => {
            const currentUrl = window.location.href.split('?')[0]; 
            const newUrl = `${currentUrl}?mode=popup`; 
            
            window.open(newUrl, '_blank', 'width=200,height=700,resizable=yes');
        });
    }

    // --- 8. VOICE CHAT IMPLEMENTATION (WebRTC & Socket.IO Signaling) ---

    // --- UI Control ---
    function updateVcControls(inCall) {
        vcBtnJoin.style.display = inCall ? 'none' : 'block';
        vcBtnMute.style.display = inCall ? 'block' : 'block'; 
        vcBtnLeave.style.display = inCall ? 'block' : 'none';
        
        if (inCall) {
            vcBtnMute.textContent = isMuted ? 'Unmute' : 'Mute';
            vcBtnMute.classList.toggle('active', isMuted);
        } else {
            vcBtnMute.textContent = 'Mute';
            vcBtnMute.classList.remove('active');
        }
    }

    // --- VC Connect ---
    vcBtnJoin.addEventListener('click', async () => {
        if (!currentUsername) {
            console.warn('Set a username before joining the voice chat.');
            return;
        }
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);

            socket.emit('vc-join');
            updateVcControls(true);
            
        } catch (err) {
            console.error('Failed to get local audio stream (User denied access or no device):', err);
            updateVcControls(false); 
        }
    });

    // --- VC Mute/Unmute ---
    vcBtnMute.addEventListener('click', () => {
        isMuted = !isMuted;
        if (localStream) {
            localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
        }
        updateVcControls(localStream !== null); 
    });

    // --- VC Leave ---
    vcBtnLeave.addEventListener('click', () => {
        socket.emit('vc-leave');
        
        Object.values(peerConnections).forEach(pc => pc.close());
        
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        
        localStream = null;
        Object.keys(peerConnections).forEach(key => delete peerConnections[key]);
        document.querySelectorAll('audio[id^="audio-"]').forEach(el => el.remove());

        updateVcControls(false);
    });

    // --- Peer Connection Handling ---

    function createPeerConnection(remoteSocketId) {
        const pc = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' } 
            ]
        });

        pc.onicecandidate = ({ candidate }) => {
            if (candidate) {
                socket.emit('webrtc-signal', remoteSocketId, { 'ice-candidate': candidate });
            }
        };

        pc.ontrack = ({ streams: [stream] }) => {
            const audioEl = document.createElement('audio');
            audioEl.srcObject = stream;
            audioEl.autoplay = true;
            audioEl.id = `audio-${remoteSocketId}`;
            
            document.body.appendChild(audioEl); 
            console.log(`Playing audio from peer ${remoteSocketId}`);
        };

        if (localStream) {
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        }

        peerConnections[remoteSocketId] = pc;
        return pc;
    }


    // --- Socket.IO WebRTC Signaling Handlers ---

    socket.on('vc-user-joined', async (newUserId) => {
        if (!localStream) return; 

        const pc = createPeerConnection(newUserId);
        
        try {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            socket.emit('webrtc-signal', newUserId, { 'offer': pc.localDescription });
        } catch (e) {
             console.error('Error creating offer:', e);
        }
    });

    socket.on('vc-user-left', (leavingUserId) => {
        if (peerConnections[leavingUserId]) {
            peerConnections[leavingUserId].close();
            delete peerConnections[leavingUserId];
        }
        const audioEl = document.getElementById(`audio-${leavingUserId}`);
        if (audioEl) audioEl.remove();
        console.log(`Removed connection and audio for peer ${leavingUserId}`);
    });

    socket.on('webrtc-signal', async (fromId, signal) => {
        let pc = peerConnections[fromId];
        
        if (signal.offer) {
            if (!localStream) return; 

            if (!pc) pc = createPeerConnection(fromId); 

            try {
                await pc.setRemoteDescription(new RTCSessionDescription(signal.offer));
                
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                
                socket.emit('webrtc-signal', fromId, { 'answer': pc.localDescription });
            } catch (e) {
                console.error('Error handling offer/answer:', e);
            }
            
        } else if (signal.answer) {
            if (pc && pc.signalingState !== 'stable') {
                 try {
                    await pc.setRemoteDescription(new RTCSessionDescription(signal.answer));
                } catch (e) {
                    console.error('Error setting remote description for answer:', e);
                }
            }
        } else if (signal['ice-candidate']) {
            if (pc) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(signal['ice-candidate']));
                } catch (e) {
                }
            }
        }
    });

    // --- Socket.IO VC User List Update ---

    socket.on('vc-user-list-update', (users) => {
        vcUserList.innerHTML = '';
        users.forEach(user => {
            const li = document.createElement('li');
            li.textContent = `üü¢ ${user}`; 
            vcUserList.appendChild(li);
        });
    });

    updateVcControls(false); 
    
</script>


</body>
</html>
