<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple Chat App</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="chat-container">
        <div id="username-area">
            <button id="avatar-upload-btn" title="Set Avatar (Click to Upload)">
                <img id="current-avatar-preview" src="placeholder-avatar.png" alt="Avatar">
            </button>
            <h3>username:</h3>
            <input type="text" id="username-input" placeholder="whatr we callin ya">
            <button id="set-username-btn">Save</button>
        </div>

        <div id="online-users-area">
            <h4>whos online:</h4>
            <ul id="online-users-list">
                </ul>
        </div>
        
        <div id="messages">
            </div>

        <div id="message-input-area">
            <div id="image-preview-area" style="display:none;">
                <img id="image-preview" src="" alt="Image Preview">
                <button id="remove-image-btn">X</button>
            </div>
            <textarea id="message-input" placeholder="type type type..." rows="1"></textarea>
            <button id="file-upload-btn" title="File Upload (Not implemented)">
                üìÅ
            </button>
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <div id="right-panel">
        <h4 class="panel-title">other stuff</h4>
        <button id="launch-custom-window-btn" class="panel-btn">resizable window</button>
        <p class="panel-hint">for a dedicated status/chat window.</p>

        <h4 class="panel-title">voice chat</h4>
        <button id="vc-btn-join" class="panel-btn">Join Call</button>
        <button id="vc-btn-mute" class="panel-btn">Mute</button>
        <ul id="vc-user-list">
            </ul>
        </div>
    
</div>

<script>
    // --- 0. Popup Mode Check (CRITICAL: Hides the side panel when URL contains ?mode=popup) ---
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'popup') {
        const mainWrapper = document.getElementById('main-wrapper');
        const rightPanel = document.getElementById('right-panel');
        const chatContainer = document.getElementById('chat-container');
        
        // Selectors for Input Area elements
        const messageInputArea = document.getElementById('message-input-area');
        const fileUploadBtn = document.getElementById('file-upload-btn');
        const sendButton = document.getElementById('send-button');

        if (mainWrapper) {
            mainWrapper.style.gap = '0';
            mainWrapper.style.maxWidth = '150px'; 
        }
        if (rightPanel) {
            rightPanel.style.display = 'none';
        }
        if (chatContainer) {
            chatContainer.style.maxWidth = '100%';
        }

        // --- NEW INPUT LAYOUT FOR POPUP MODE ---
        if (messageInputArea) {
            messageInputArea.style.flexDirection = 'column';
            messageInputArea.style.gap = '5px';
        }
        if (fileUploadBtn) {
            fileUploadBtn.style.width = '100%';
            fileUploadBtn.style.alignSelf = 'stretch';
        }
        if (sendButton) {
            sendButton.style.width = '100%';
            sendButton.style.alignSelf = 'stretch';
        }
        // --- END NEW INPUT LAYOUT ---
    }
    // ------------------------------------

    const socket = io();

    // --- DOM Elements ---
    const messagesDiv = document.getElementById('messages');
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const onlineUsersList = document.getElementById('online-users-list');
    const launchCustomWindowBtn = document.getElementById('launch-custom-window-btn');
    
    // NEW AVATAR ELEMENTS
    const avatarUploadBtn = document.getElementById('avatar-upload-btn');
    const currentAvatarPreview = document.getElementById('current-avatar-preview');


    let currentUsername = '';
    let currentAvatarBase64 = ''; // Store the Base64 string here
    let lastMessageSender = ''; // Unified sender tracker
    let lastMessageTime = 0; // Unified time tracker

    // --- 1. Utility Function to Handle Formatting ---
    function parseFormatting(text) {
        let formattedText = text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        // Crossout: ~~text~~ with <del>text</del>
        formattedText = formattedText.replace(/~~(.*?)~~/g, '<del>$1</del>');
        
        // Bold: **text** with <strong>text</strong>
        formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        // Underline: __text__ with <u>text</u>
        formattedText = formattedText.replace(/__(.*?)\b__/g, '<u>$1</u>'); 
        
        // Slanted (Italics): *text* with <em>text</em>
        formattedText = formattedText.replace(/\*(.*?)\*/g, '<em>$1</em>');
        
        // UNSANITIZE only the newly added HTML tags for rendering
        formattedText = formattedText.replace(/&lt;del&gt;/g, '<del>').replace(/&lt;\/del&gt;/g, '</del>');
        formattedText = formattedText.replace(/&lt;strong&gt;/g, '<strong>').replace(/&lt;\/strong&gt;/g, '</strong>');
        formattedText = formattedText.replace(/&lt;u&gt;/g, '<u>').replace(/&lt;\/u&gt;/g, '</u>');
        formattedText = formattedText.replace(/&lt;em&gt;/g, '<em>').replace(/&lt;\/em&gt;/g, '</em>');

        return formattedText;
    }

    // --- 2. Avatar Selection and Conversion ---
    
    avatarUploadBtn.addEventListener('click', () => {
        // Create an invisible file input element
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onloadend = () => {
                    // reader.result is the Base64 Data URL
                    currentAvatarBase64 = reader.result;
                    currentAvatarPreview.src = currentAvatarBase64; // Update UI preview
                    
                    // If username is already set, resend profile data to server
                    if (currentUsername) {
                        setUsername(currentUsername); 
                    }
                    localStorage.setItem('chatAvatar', currentAvatarBase64);
                };
                reader.readAsDataURL(file);
            }
        });
        
        fileInput.click(); // Programmatically click the hidden input
    });


    // --- 3. Username Handling ---
    
    document.addEventListener('DOMContentLoaded', () => {
        const storedUsername = localStorage.getItem('chatUsername');
        const storedAvatar = localStorage.getItem('chatAvatar');

        if (storedAvatar) {
            currentAvatarBase64 = storedAvatar;
            currentAvatarPreview.src = currentAvatarBase64;
        } else {
             // Set default avatar image placeholder if none is stored
            currentAvatarPreview.src = 'placeholder-avatar.png';
        }

        if (storedUsername) {
            usernameInput.value = storedUsername;
            setUsername(storedUsername);
        }
    });

    setUsernameBtn.addEventListener('click', () => {
        const username = usernameInput.value.trim();
        if (username) {
            localStorage.setItem('chatUsername', username);
            if (currentAvatarBase64) {
                 localStorage.setItem('chatAvatar', currentAvatarBase64);
            }
            setUsername(username);
        } else {
            console.warn('Please enter a username.');
        }
    });
    
    function setUsername(username) {
        currentUsername = username;
        // UPDATED: Send both username and avatar
        socket.emit('set-username', { 
            username: currentUsername, 
            avatar: currentAvatarBase64 || 'placeholder-avatar.png'
        }); 
        usernameInput.disabled = true;
        setUsernameBtn.disabled = true;
        usernameInput.placeholder = 'Username set!';
        messageInput.focus();
    }

    // --- 4. Message Sending ---

    function sendMessage() {
        let msg = messageInput.value.trim();
        if (!msg || !currentUsername) return; 

        socket.emit('chat-message', msg);
        messageInput.value = '';
    }

    sendButton.addEventListener('click', sendMessage);

    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // --- 5. Message Display Helper Function (Grouping Logic) ---
    // UPDATED: Accepts message object { text, avatar, sender }
    function displayMessage(messageObject) {
        
        // Determine if it's a simple history string or a system message object
        if (typeof messageObject === 'string' || messageObject.avatar === null) {
            var formattedMessage = messageObject.text || messageObject; // messageObject is just the text string from history
            var messageAvatar = null;
            var sender = null;
        } else {
            // Regular chat message object
            var formattedMessage = messageObject.text;
            var messageAvatar = messageObject.avatar;
            var sender = messageObject.sender;
        }

        const messageEl = document.createElement('div');
        messageEl.classList.add('message');

        // Regex 1: Regular messages (HAS colon) **[User]**: [Message Text] [Time]
        const fullMatch = formattedMessage.match(/\*\*(.*?)\*\*: (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);

        // --- Handle System Messages/Announcements ---
        if (!fullMatch) {
            // Check for the System format: **[User]** [Message Text] [Time] (No colon)
            const systemMatch = formattedMessage.match(/\*\*(.*?)\*\* (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);
            
            // CRITICAL: Reset trackers on system message
            lastMessageTime = 0; 
            lastMessageSender = ''; 

            if (systemMatch) {
                messageEl.classList.add('system-message');
                const systemText = systemMatch[2];
                
                // Private Message Check 
                if (systemText.startsWith('**[PM from') || systemText.startsWith('**[PM to')) {
                    messageEl.classList.add('private-message');
                    let pmContent = systemText.replace(/\*\*(.*?)\*\*/, '$1'); 
                    messageEl.innerHTML = parseFormatting(`<u>${pmContent}</u>`); 

                    messagesDiv.appendChild(messageEl);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    return; 
                }
                
                // Standard System Message / Announcement
                messageEl.innerHTML = parseFormatting(systemText);
                messagesDiv.appendChild(messageEl);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                return;
            }
            
            // Fallback for unparseable system messages/errors
            messageEl.classList.add('system-message');
            messageEl.innerHTML = parseFormatting(formattedMessage);
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return;
        }
        
        // Extracted parts for REGULAR messages:
        const extractedSender = fullMatch[1];
        const messageText = fullMatch[2];
        const timeString = fullMatch[3]; 

        // Use the sender and avatar from the message object, or fallback to extracted text
        const finalSender = sender || extractedSender;
        const finalAvatar = messageAvatar || 'placeholder-avatar.png'; // Use a default if avatar is missing


        // 1. Determine alignment class, tracking variables, and grouping logic
        const isUserMessage = (finalSender === currentUsername);
        let showAvatar = true;
        let showUsername = true; 

        // --- Calculate Time in Minutes for Grouping ---
        let currentTimeInMinutes = 0;
        const timeParts = timeString.match(/(\d{1,2}):(\d{2}) (AM|PM)/);
        if (timeParts) {
            let hours = parseInt(timeParts[1]);
            const minutes = parseInt(timeParts[2]);
            const isPM = timeParts[3] === 'PM';
            
            if (isPM && hours !== 12) hours += 12;
            if (!isPM && hours === 12) hours = 0;
            currentTimeInMinutes = hours * 60 + minutes;
        }


        // 1a. Set base alignment
        if (isUserMessage) {
            messageEl.classList.add('user-message');
            showUsername = false; // Never show username on self-messages
        } else {
            messageEl.classList.add('other-message');
        }


        // 1b. Unified Grouping Logic
        // Group if the sender is the same AND less than 1 minute has passed
        const shouldGroup = (lastMessageSender === finalSender) && (currentTimeInMinutes - lastMessageTime) < 1;

        if (shouldGroup) {
            showAvatar = false; 
            showUsername = false; 
            messageEl.classList.add('grouped-message');

            // CRITICAL RETROACTIVE FIX (Removes time from the previous message)
            const previousMessageEl = messagesDiv.lastChild;
            if (previousMessageEl) {
                // Ensure we don't accidentally remove time from a system message
                if (!previousMessageEl.classList.contains('system-message')) {
                     const prevContentWrapper = previousMessageEl.querySelector('.message-content-wrapper');
                    if (prevContentWrapper) {
                        const prevTimeSpan = prevContentWrapper.querySelector('.message-time');
                        if (prevTimeSpan) {
                            prevTimeSpan.remove(); // DELETE TIME from the previous message
                        }
                    }
                }
            }
        } 

        // 1c. Update Tracking Variables (After Grouping Check)
        lastMessageSender = finalSender;
        lastMessageTime = currentTimeInMinutes;
        

        // --- 2. Assemble the Message Structure ---
        
        // 2a. Avatar (Always add either the image or a spacer)
        if (!isUserMessage) {
            // Other User Messages: Avatar (Left) / Content (Right)
            if (showAvatar) {
                const avatarImg = document.createElement('img');
                avatarImg.classList.add('avatar');
                avatarImg.src = finalAvatar;
                messageEl.appendChild(avatarImg);
            } else {
                // Spacer for grouped messages
                const spacer = document.createElement('div');
                spacer.classList.add('avatar-spacer');
                messageEl.appendChild(spacer);
            }
        }
        
        // 2b. Content Area Wrapper
        const contentArea = document.createElement('div');
        contentArea.classList.add('message-content-area');
        
        // 2c. Username (Only for other users, when showUsername is true)
        if (showUsername && !isUserMessage) {
            const usernameDiv = document.createElement('div');
            usernameDiv.classList.add('message-username');
            usernameDiv.innerHTML = `<strong>${finalSender}</strong><span class="username-separator">:</span>`;
            contentArea.appendChild(usernameDiv);
        }

        // 2d. Content Wrapper (Bubble + Time)
        const contentWrapper = document.createElement('div');
        contentWrapper.classList.add('message-content-wrapper');
        
        const bubbleContent = document.createElement('span');
        bubbleContent.classList.add('bubble-content');
        
        let contentHtml = parseFormatting(messageText); 

        bubbleContent.innerHTML = contentHtml;
        contentWrapper.appendChild(bubbleContent); 
        
        // 2e. Time Content (Renders only for the last message in a group)
        const timeSpan = document.createElement('span');
        timeSpan.classList.add('message-time');
        timeSpan.textContent = timeString; 
        contentWrapper.appendChild(timeSpan); 
        

        // 3. Assemble the final message element
        contentArea.appendChild(contentWrapper);

        if (isUserMessage) {
            // User Messages: Content (Left) / Avatar (Right)
            messageEl.appendChild(contentArea);
        } else {
            // Other Messages: Avatar (Left) / Content (Right) - Avatar already added in 2a
            messageEl.appendChild(contentArea);
        }
        
        messagesDiv.appendChild(messageEl);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // --- 6. Receiving Messages (History and Live) ---
    
    // History messages are simple strings from the server log
    socket.on('history', (history) => {
        // Reset trackers before starting the loop
        lastMessageTime = 0; 
        lastMessageSender = ''; 
        messagesDiv.innerHTML = ''; 

        // Loop through history messages sequentially
        history.forEach(msg => {
            // Pass the string directly. displayMessage handles parsing the sender/time from the string.
            displayMessage(msg); 
        });
        
        messagesDiv.scrollTop = messagesDiv.scrollHeight; 
    });

    // Live messages are objects { text, avatar, sender }
    socket.on('chat-message', (messageObject) => {
        displayMessage(messageObject);
    });

    socket.on('clear-chat', () => {
        messagesDiv.innerHTML = '';
    });

    // --- 7. Online User List Update ---
    
    // User list is an array of objects { username, avatar }
    socket.on('user-list-update', (users) => {
        onlineUsersList.innerHTML = '';
        users.forEach(userData => {
            const li = document.createElement('li');
            
            // Add list avatar
            const listAvatar = document.createElement('img');
            listAvatar.classList.add('avatar', 'list-avatar');
            listAvatar.src = userData.avatar || 'placeholder-avatar.png'; // Use stored avatar
            li.appendChild(listAvatar);

            li.appendChild(document.createTextNode(userData.username));
            onlineUsersList.appendChild(li);
        });
    });

    // --- 8. Launch Custom Window Logic ---
    if (launchCustomWindowBtn) {
         launchCustomWindowBtn.addEventListener('click', () => {
            const currentUrl = window.location.href.split('?')[0]; 
            const newUrl = `${currentUrl}?mode=popup`; 
            
            window.open(newUrl, '_blank', 'width=200,height=700,resizable=yes');
        });
    }
    
</script>


</body>
</html>
