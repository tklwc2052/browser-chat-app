<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple Chat App</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="chat-container">
        <div id="username-area">
            <button id="avatar-upload-btn" title="Set Avatar">
                <img id="current-avatar-preview" src="placeholder-avatar.png" alt="Avatar">
            </button>
            <h3>username:</h3>
            <input type="text" id="username-input" placeholder="whatr we callin ya">
            <button id="set-username-btn">Save</button>
        </div>

        <div id="online-users-area">
            <h4>whos online:</h4>
            <ul id="online-users-list"></ul>
        </div>
        
        <div id="messages"></div>

        <div id="message-input-area">
            <div id="image-preview-area" style="display:none;">
                <img id="image-preview" src="" alt="Image Preview">
                <button id="remove-image-btn">X</button>
            </div>
            
            <textarea id="message-input" placeholder="type type type..." rows="1"></textarea>
            
            <input type="file" id="hidden-file-input" accept="image/*" style="display: none;">
            
            <button id="file-upload-btn" title="Upload Image">üìÅ</button>
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <div id="right-panel">
        <h4 class="panel-title">other stuff</h4>
        <button id="launch-custom-window-btn" class="panel-btn">resizable window</button>

        <h4 class="panel-title">voice chat</h4>
        <button id="vc-btn-join" class="panel-btn">Join Call</button>
        <button id="vc-btn-mute" class="panel-btn" style="display: none;">Mute</button>
        <ul id="vc-user-list"></ul>
        <div id="audio-container" style="display:none;"></div>
    </div>
    
</div>

<script>
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'popup') {
        document.getElementById('right-panel').style.display = 'none';
        document.getElementById('main-wrapper').style.maxWidth = '100%';
    }

    const socket = io();

    // --- DOM Elements ---
    const messagesDiv = document.getElementById('messages');
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const onlineUsersList = document.getElementById('online-users-list');
    const launchCustomWindowBtn = document.getElementById('launch-custom-window-btn');
    const avatarUploadBtn = document.getElementById('avatar-upload-btn');
    const currentAvatarPreview = document.getElementById('current-avatar-preview');
    const vcBtnJoin = document.getElementById('vc-btn-join');
    const vcBtnMute = document.getElementById('vc-btn-mute');
    const vcUserList = document.getElementById('vc-user-list');
    const audioContainer = document.getElementById('audio-container');
    
    // NEW: Image Handling Elements
    const fileUploadBtn = document.getElementById('file-upload-btn');
    const hiddenFileInput = document.getElementById('hidden-file-input');
    const imagePreviewArea = document.getElementById('image-preview-area');
    const imagePreview = document.getElementById('image-preview');
    const removeImageBtn = document.getElementById('remove-image-btn');

    let currentUsername = '';
    let currentAvatarBase64 = ''; 
    let lastMessageSender = ''; 
    let stagedImage = null; // Holds the image data waiting to be sent
    
    // --- WebRTC State ---
    let localStream = null;
    let peers = {}; 
    let isInVC = false;
    let audioCtx; 
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // ==========================================
    // --- 1. IMAGE HANDLING (Select -> Stage -> Send) ---
    // ==========================================

    // Helper: Read file and stage it
    function handleFileSelection(file) {
        if (!file || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            stagedImage = e.target.result;
            imagePreview.src = stagedImage;
            imagePreviewArea.style.display = 'flex';
        };
        reader.readAsDataURL(file);
    }

    // A. Button Click
    fileUploadBtn.addEventListener('click', () => hiddenFileInput.click());
    hiddenFileInput.addEventListener('change', (e) => handleFileSelection(e.target.files[0]));

    // B. Paste Event (Ctrl+V)
    messageInput.addEventListener('paste', (e) => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.kind === 'file' && item.type.startsWith('image/')) {
                const file = item.getAsFile();
                handleFileSelection(file);
                e.preventDefault(); // Don't paste binary garbage into text area
            }
        }
    });

    // C. Drag & Drop
    window.addEventListener('dragover', (e) => e.preventDefault());
    window.addEventListener('drop', (e) => {
        e.preventDefault();
        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
            handleFileSelection(e.dataTransfer.files[0]);
        }
    });

    // D. Remove Staged Image
    removeImageBtn.addEventListener('click', () => {
        stagedImage = null;
        imagePreview.src = '';
        imagePreviewArea.style.display = 'none';
        hiddenFileInput.value = ''; // Reset input
    });

    // ==========================================
    // --- 2. LOGIC ---
    // ==========================================

    // --- Avatar ---
    avatarUploadBtn.addEventListener('click', () => {
        const fileInput = document.createElement('input');
        fileInput.type = 'file'; fileInput.accept = 'image/*';
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onloadend = () => {
                    currentAvatarBase64 = reader.result;
                    currentAvatarPreview.src = currentAvatarBase64; 
                    if (currentUsername) setUsername(currentUsername); 
                    localStorage.setItem('chatAvatar', currentAvatarBase64);
                };
                reader.readAsDataURL(file);
            }
        });
        fileInput.click();
    });

    document.addEventListener('DOMContentLoaded', () => {
        const storedUsername = localStorage.getItem('chatUsername');
        const storedAvatar = localStorage.getItem('chatAvatar');
        if (storedAvatar) { currentAvatarBase64 = storedAvatar; currentAvatarPreview.src = storedAvatar; }
        if (storedUsername) { usernameInput.value = storedUsername; setUsername(storedUsername); }
    });

    setUsernameBtn.addEventListener('click', () => {
        const username = usernameInput.value.trim();
        if (username) { localStorage.setItem('chatUsername', username); setUsername(username); }
    });
    
    function setUsername(username) {
        currentUsername = username;
        socket.emit('set-username', { username, avatar: currentAvatarBase64 || 'placeholder-avatar.png' }); 
        usernameInput.disabled = true; setUsernameBtn.disabled = true;
    }

    // --- Sending Messages (UPDATED) ---
    function sendMessage() {
        const text = messageInput.value.trim();
        
        // Don't send if empty AND no image
        if ((!text && !stagedImage) || !currentUsername) return; 

        const payload = {
            text: text,
            image: stagedImage // Send null if no image
        };

        socket.emit('chat-message', payload);
        
        // Reset UI
        messageInput.value = '';
        stagedImage = null;
        imagePreviewArea.style.display = 'none';
        hiddenFileInput.value = '';
    }

    sendButton.addEventListener('click', sendMessage);
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
    });
    
    function parseFormatting(text) {
        if (!text) return '';
        return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
            .replace(/~~(.*?)~~/g, '<del>$1</del>')
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>');
    }

    function displayMessage(msg) {
        const messageEl = document.createElement('div');
        messageEl.classList.add('message');

        // Private Msg
        if (msg.type === 'private') {
            const isMe = (msg.sender === currentUsername);
            isMe ? messageEl.classList.add('user-message') : messageEl.classList.add('other-message');
            const contentArea = document.createElement('div');
            contentArea.classList.add('message-content-area', 'private-message-container');
            const label = document.createElement('span');
            label.classList.add('pm-label');
            label.innerText = isMe ? `Private to ${msg.target}` : `Private from ${msg.sender}`;
            contentArea.appendChild(label);
            const bubble = document.createElement('div');
            bubble.classList.add('bubble-content', 'bubble-private');
            bubble.innerHTML = parseFormatting(msg.text);
            contentArea.appendChild(bubble);
            const time = document.createElement('div');
            time.classList.add('message-time');
            time.innerText = msg.time;
            contentArea.appendChild(time);
            messageEl.appendChild(contentArea);
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            lastMessageSender = ''; 
            return;
        }

        // System Msg
        if (msg.type === 'system' || msg.text.startsWith('**System**') || msg.text.startsWith('**Announcement**')) {
            messageEl.classList.add('system-message');
            let displayText = msg.text;
            if (displayText.startsWith('**System**')) displayText = displayText.replace(/^\*\*System\*\* /, '').replace(/ \[.*?\]$/, '');
            if (displayText.startsWith('**Announcement**')) displayText = displayText.replace(/^\*\*Announcement\*\* /, '').replace(/ \[.*?\]$/, '');
            messageEl.innerHTML = parseFormatting(displayText);
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            lastMessageSender = ''; 
            return;
        }

        // General Msg
        const isUserMessage = (msg.sender === currentUsername);
        isUserMessage ? messageEl.classList.add('user-message') : messageEl.classList.add('other-message');

        let showAvatar = true;
        if (lastMessageSender === msg.sender) {
            showAvatar = false;
            messageEl.classList.add('grouped-message');
        }
        lastMessageSender = msg.sender;

        if (!isUserMessage) {
            if (showAvatar) {
                const img = document.createElement('img');
                img.classList.add('avatar'); img.src = msg.avatar || 'placeholder-avatar.png';
                messageEl.appendChild(img);
            } else {
                const spacer = document.createElement('div');
                spacer.classList.add('avatar-spacer');
                messageEl.appendChild(spacer);
            }
        }

        const contentArea = document.createElement('div');
        contentArea.classList.add('message-content-area');

        if (showAvatar && !isUserMessage) {
            const uDiv = document.createElement('div');
            uDiv.classList.add('message-username');
            uDiv.innerText = msg.sender;
            contentArea.appendChild(uDiv);
        }

        const bubble = document.createElement('div');
        bubble.classList.add('bubble-content');
        
        // --- IMAGE RENDERING ---
        if (msg.image) {
            const imgEl = document.createElement('img');
            imgEl.src = msg.image;
            imgEl.classList.add('message-image');
            imgEl.onclick = () => { /* Optional: Expand logic */ };
            bubble.appendChild(imgEl);
        }
        
        // Text rendering (if text exists)
        if (msg.text) {
             const textSpan = document.createElement('div');
             textSpan.innerHTML = parseFormatting(msg.text.replace(`**${msg.sender}**: `, '').replace(/ \[.*?\]$/, ''));
             bubble.appendChild(textSpan);
        }
        
        const time = document.createElement('div');
        time.classList.add('message-time');
        time.innerText = msg.time;

        const wrapper = document.createElement('div');
        wrapper.classList.add('message-content-wrapper');
        wrapper.appendChild(bubble);
        wrapper.appendChild(time);

        contentArea.appendChild(wrapper);
        messageEl.appendChild(contentArea);
        messagesDiv.appendChild(messageEl);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // --- 3. VOICE CHAT ---
    function attachSpeakingDetector(stream, userId) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        source.connect(analyser);
        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        function checkVolume() {
            if (!isInVC) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            const average = sum / dataArray.length;
            const userLi = document.getElementById(`vc-user-${userId}`);
            if (userLi) {
                if (average > 10) userLi.classList.add('speaking');
                else userLi.classList.remove('speaking');
            }
            requestAnimationFrame(checkVolume);
        }
        checkVolume();
    }

    async function startVC() {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            attachSpeakingDetector(localStream, socket.id);
            isInVC = true;
            vcBtnJoin.textContent = 'Leave Call';
            vcBtnJoin.style.backgroundColor = 'var(--color-vc-red)';
            vcBtnMute.style.display = 'block';
            socket.emit('vc-join', true);
        } catch (err) { console.error(err); alert('Microphone access denied.'); }
    }

    function leaveVC() {
        socket.emit('vc-join', false);
        if (localStream) { localStream.getTracks().forEach(track => track.stop()); localStream = null; }
        Object.keys(peers).forEach(key => { peers[key].close(); delete peers[key]; });
        isInVC = false;
        vcBtnJoin.textContent = 'Join Call';
        vcBtnJoin.style.backgroundColor = '';
        vcBtnMute.style.display = 'none';
    }

    function createPeerConnection(targetId, initiator) {
        if (peers[targetId]) return;
        const peer = new RTCPeerConnection(rtcConfig);
        peers[targetId] = peer;
        if (localStream) localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
        peer.ontrack = (event) => {
            let audioEl = document.getElementById(`audio-${targetId}`);
            if (!audioEl) {
                audioEl = document.createElement('audio');
                audioEl.id = `audio-${targetId}`;
                audioEl.autoplay = true;
                audioContainer.appendChild(audioEl);
            }
            audioEl.srcObject = event.streams[0];
            attachSpeakingDetector(event.streams[0], targetId);
        };
        peer.onicecandidate = (event) => {
            if (event.candidate) socket.emit('signal', { target: targetId, signal: { type: 'candidate', candidate: event.candidate } });
        };
        if (initiator) {
            peer.createOffer().then(offer => peer.setLocalDescription(offer))
                .then(() => socket.emit('signal', { target: targetId, signal: { type: 'offer', sdp: peer.localDescription } }));
        }
        return peer;
    }

    socket.on('vc-user-joined', (id) => { if (isInVC) createPeerConnection(id, true); });
    socket.on('vc-user-left', (id) => { 
        if (peers[id]) { peers[id].close(); delete peers[id]; }
        const el = document.getElementById(`audio-${id}`); if (el) el.remove();
    });
    socket.on('signal', async ({ sender, signal }) => {
        if (!isInVC) return;
        let peer = peers[sender];
        if (!peer) peer = createPeerConnection(sender, false);
        if (signal.type === 'offer') {
            await peer.setRemoteDescription(new RTCSessionDescription(signal.sdp));
            const answer = await peer.createAnswer();
            await peer.setLocalDescription(answer);
            socket.emit('signal', { target: sender, signal: { type: 'answer', sdp: answer } });
        } else if (signal.type === 'answer') {
            await peer.setRemoteDescription(new RTCSessionDescription(signal.sdp));
        } else if (signal.type === 'candidate') {
            try { await peer.addIceCandidate(new RTCIceCandidate(signal.candidate)); } catch(e){}
        }
    });
    vcBtnJoin.addEventListener('click', () => { if (!currentUsername) return alert("Set username first."); isInVC ? leaveVC() : startVC(); });
    vcBtnMute.addEventListener('click', () => {
        if (!localStream) return;
        const track = localStream.getAudioTracks()[0];
        track.enabled = !track.enabled;
        vcBtnMute.textContent = track.enabled ? 'Mute' : 'Unmute';
        socket.emit('vc-mute-toggle', !track.enabled);
    });
    socket.on('vc-user-list-update', (users) => {
        vcUserList.innerHTML = '';
        users.forEach(u => {
            const li = document.createElement('li');
            li.id = `vc-user-${u.id}`; 
            const img = document.createElement('img');
            img.classList.add('avatar', 'list-avatar'); img.src = u.avatar;
            li.appendChild(img); li.appendChild(document.createTextNode(u.username));
            if (u.isMuted) li.innerHTML += ' <span style="color:var(--color-vc-red)">üîá</span>';
            vcUserList.appendChild(li);
        });
    });

    socket.on('chat-message', displayMessage);
    socket.on('history', (h) => { messagesDiv.innerHTML = ''; h.forEach(displayMessage); });
    socket.on('clear-chat', () => { messagesDiv.innerHTML = ''; console.log("Chat cleared."); });
    socket.on('user-list-update', (users) => {
        onlineUsersList.innerHTML = '';
        users.forEach(u => {
            const li = document.createElement('li');
            const img = document.createElement('img');
            img.classList.add('avatar', 'list-avatar'); img.src = u.avatar;
            li.appendChild(img); li.appendChild(document.createTextNode(u.username));
            onlineUsersList.appendChild(li);
        });
    });
    if (launchCustomWindowBtn) launchCustomWindowBtn.addEventListener('click', () => {
        window.open(`${window.location.href.split('?')[0]}?mode=popup`, '_blank', 'width=200,height=700,resizable=yes');
    });
</script>
</body>
</html>
