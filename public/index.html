<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The C&C Corp chat</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>

<style>
    .message-content-area {
        display: flex;
        flex-direction: column;
        max-width: 70%;
        position: relative;
    }
    .message-sender-name {
        font-size: 0.75rem; 
        color: #888;
        margin-bottom: 2px;
        margin-left: 4px;
        font-weight: 700;
        letter-spacing: 0.5px;
        cursor: pointer;
        transition: color 0.2s;
    }
    .message-sender-name:hover {
        color: #00ACE6;
        text-decoration: underline;
    }
    .user-message .message-content-area { align-items: flex-end; }
    .user-message .message-sender-name { margin-right: 4px; margin-left: 0; color: #00ACE6; }
</style>
</head>
<body>
<div id="main-wrapper">

    <div id="dm-sidebar">
        <div id="dm-header">Contacts</div>
        <div id="dm-list"></div>
    </div>

    <div id="chat-container">
        
        <div id="chat-header">
            <button id="toggle-sidebar-btn" class="header-btn">‚ò∞</button>
            <div id="header-title">The C&C Corp chat</div>
            <div id="connection-status">Connecting...</div>
            <button id="profile-btn" class="header-btn" style="margin-left: auto;">Profile</button>
            <button id="settings-btn" class="header-btn">‚öôÔ∏è</button>
        </div>

        <div id="chat-box"></div>
        
        <div id="reply-bar">
            <span>Replying to <b id="reply-target-name">...</b></span>
            <button id="cancel-reply">‚úï</button>
        </div>

        <div id="image-preview-area">
            <img id="image-preview-img" src="" alt="Preview">
            <button id="remove-image-btn">‚úï</button>
        </div>

        <div id="input-area">
            <button id="upload-btn" title="Upload Image">+</button>
            <input type="file" id="hidden-file-input" accept="image/*" style="display: none;">
            
            <input type="text" id="message-input" placeholder="Type a message..." autocomplete="off">
            <button id="send-btn">Send</button>
        </div>
    </div>

    <div id="user-sidebar">
        <div class="sidebar-section-title">Voice Chat</div>
        <div id="vc-controls">
            <button id="join-vc-btn" class="vc-btn-join">Join Voice</button>
            <button id="leave-vc-btn" class="vc-btn-leave" style="display:none;">Leave Voice</button>
        </div>
        <div id="vc-user-list"></div>

        <div class="sidebar-section-title">Online Users</div>
        <ul id="user-list"></ul>
    </div>

</div>

<div id="settings-modal" class="modal">
    <div class="modal-content">
        <span id="close-settings" class="close">&times;</span>
        <h2>Settings</h2>
        <div class="setting-item">
            <button id="btn-cloak-launcher" class="d-btn d-btn-secondary">Launch in Cloaked Tab</button>
            <p style="font-size: 0.8rem; color: #aaa;">Opens chat in about:blank to hide from history.</p>
        </div>
        <div class="setting-item">
            <button id="btn-custom-window" class="d-btn d-btn-secondary">Popout Chat Window</button>
        </div>
        <div class="setting-item">
            <label>Custom Chat Background</label><br>
            <button id="btn-bg-upload" class="d-btn d-btn-primary">Upload Background</button>
            <button id="btn-bg-reset" class="d-btn d-btn-secondary">Reset</button>
            <input type="file" id="bg-upload-input" accept="image/*" style="display:none">
        </div>
    </div>
</div>

<script>
    const socket = io();
    
    // Elements
    const chatBox = document.getElementById('chat-box');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const userList = document.getElementById('user-list');
    const connectionStatus = document.getElementById('connection-status');
    const headerTitle = document.getElementById('header-title');
    
    // Uploads
    const uploadBtn = document.getElementById('upload-btn');
    const hiddenFileInput = document.getElementById('hidden-file-input');
    const imagePreviewArea = document.getElementById('image-preview-area');
    const imagePreviewImg = document.getElementById('image-preview-img');
    const removeImageBtn = document.getElementById('remove-image-btn');

    // Reply
    const replyBar = document.getElementById('reply-bar');
    const replyTargetName = document.getElementById('reply-target-name');
    const cancelReplyBtn = document.getElementById('cancel-reply');

    // DM & Sidebar
    const dmSidebar = document.getElementById('dm-sidebar');
    const toggleSidebarBtn = document.getElementById('toggle-sidebar-btn');
    const dmListEl = document.getElementById('dm-list');

    // VC
    const joinVcBtn = document.getElementById('join-vc-btn');
    const leaveVcBtn = document.getElementById('leave-vc-btn');
    const vcUserList = document.getElementById('vc-user-list');

    // Settings
    const settingsBtn = document.getElementById('settings-btn');
    const settingsModal = document.getElementById('settings-modal');
    const closeSettings = document.getElementById('close-settings');
    const btnCloakLauncher = document.getElementById('btn-cloak-launcher');
    const launchCustomWindowBtn = document.getElementById('btn-custom-window');
    const btnBgUpload = document.getElementById('btn-bg-upload');
    const btnBgReset = document.getElementById('btn-bg-reset');
    const bgUploadInput = document.getElementById('bg-upload-input');
    const profileBtn = document.getElementById('profile-btn');

    // State
    let currentUsername = "";
    let stagedImage = null; // URL or Base64 of image to send
    let currentReplyTo = null; // Object of message being replied to
    let currentChatMode = 'global'; // 'global' or 'dm'
    let currentDmTarget = null;
    let dmMessagesCache = {}; // { username: [msgObjects] }
    let unreadCounts = {}; // { username: count }

    // Init from LocalStorage
    const savedBg = localStorage.getItem('custom_bg');
    if (savedBg) document.body.style.backgroundImage = `url('${savedBg}')`;

    // --- AUTH ---
    const username = prompt("Enter your username:") || "Guest" + Math.floor(Math.random() * 1000);
    currentUsername = username;
    socket.emit('join', username);

    // --- SOCKET EVENTS ---

    socket.on('connect', () => {
        connectionStatus.innerText = "Online";
        connectionStatus.style.color = "#43b581";
    });

    socket.on('disconnect', () => {
        connectionStatus.innerText = "Offline";
        connectionStatus.style.color = "#f04747";
    });

    socket.on('server-build-info', (data) => {
        const savedId = localStorage.getItem('build_id');
        if (savedId && savedId != data.id) {
            // Update detected
            const sysMsg = document.createElement('div');
            sysMsg.className = 'system-message';
            sysMsg.innerHTML = `<span>üöÄ UPDATE: ${data.desc}. Refreshing...</span>`;
            chatBox.appendChild(sysMsg);
            localStorage.setItem('build_id', data.id);
            setTimeout(() => window.location.reload(), 3000);
        } else {
            localStorage.setItem('build_id', data.id);
        }
    });

    socket.on('load-history', (messages) => {
        chatBox.innerHTML = '';
        messages.forEach(msg => appendMessage(msg));
        chatBox.scrollTop = chatBox.scrollHeight;
    });

    socket.on('chat-message', (msg) => {
        if (currentChatMode === 'global') {
            appendMessage(msg);
            chatBox.scrollTop = chatBox.scrollHeight;
        } else {
            // Received global msg while in DM -> Notification?
        }
    });

    socket.on('dm-received', (data) => {
        const otherUser = (data.from === currentUsername) ? data.to : data.from;
        
        // Cache it
        if (!dmMessagesCache[otherUser]) dmMessagesCache[otherUser] = [];
        dmMessagesCache[otherUser].push(data.message);

        // Update UI if open
        if (currentChatMode === 'dm' && currentDmTarget === otherUser) {
            appendMessage(data.message);
            chatBox.scrollTop = chatBox.scrollHeight;
        } else {
            // Increment unread
            unreadCounts[otherUser] = (unreadCounts[otherUser] || 0) + 1;
            renderDmList();
        }
    });

    socket.on('update-user-list', (users) => {
        userList.innerHTML = '';
        renderDmList(users); // Refresh DM list with online status

        users.forEach(user => {
            const li = document.createElement('li');
            li.innerHTML = `
                <div class="user-item">
                    <img src="${user.avatar || 'placeholder-avatar.png'}" class="user-avatar">
                    <div class="user-info">
                        <div class="user-displayname">${user.displayName}</div>
                        <div class="user-username">@${user.username}</div>
                    </div>
                </div>
            `;
            li.onclick = () => openDm(user.username);
            userList.appendChild(li);
        });
    });

    socket.on('clear-chat', () => {
        chatBox.innerHTML = '';
        const note = document.createElement('div');
        note.className = 'system-message';
        note.innerText = 'Chat history was cleared by an admin.';
        chatBox.appendChild(note);
    });

    socket.on('profile-updated', (msg) => {
        alert(msg);
    });

    // --- FUNCTIONS ---

    function sendMessage() {
        const text = messageInput.value.trim();
        if (!text && !stagedImage) return;

        // FIX: Check if we are in DM mode and grab the target username
        const target = (currentChatMode === 'dm') ? currentDmTarget : null;

        const payload = { 
            text: text, 
            image: stagedImage, 
            replyTo: currentReplyTo,
            target: target // <-- Send the target to the server
        };

        socket.emit('chat-message', payload);
        
        messageInput.value = '';
        stagedImage = null;
        imagePreviewArea.style.display = 'none';
        hiddenFileInput.value = '';
        
        if (currentReplyTo) {
            currentReplyTo = null;
            replyBar.style.display = 'none';
        }
    }

    function appendMessage(msg) {
        const div = document.createElement('div');
        const isSelf = msg.sender === currentUsername;
        const isSystem = msg.isSystem;
        const isPm = msg.isPm;

        div.classList.add('message');
        if (isSystem) div.classList.add('system-message');
        else if (isSelf) div.classList.add('user-message');
        else div.classList.add('other-message');
        
        if (isPm) div.classList.add('pm-message');

        // Check Reply
        let replyHTML = '';
        if (msg.replyTo) {
            replyHTML = `
                <div class="message-reply-preview">
                    <div class="reply-line"></div>
                    <span class="reply-sender">@${msg.replyTo.sender}</span>: 
                    <span class="reply-text">${msg.replyTo.text || '[Image]'}</span>
                </div>
            `;
        }

        const time = new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        
        // Avatar
        const avatarImg = `<img src="${msg.avatar || 'placeholder-avatar.png'}" class="msg-avatar" onclick="openProfile('${msg.sender}')">`;

        // Content
        let contentHTML = '';
        if (msg.image) {
            contentHTML += `<img src="${msg.image}" class="message-image" onclick="window.open(this.src)">`;
        }
        if (msg.text) {
            contentHTML += `<div class="message-text">${linkify(msg.text)}</div>`;
        }

        if (isSystem) {
            div.innerText = msg.text;
        } else {
            div.innerHTML = `
                ${!isSelf ? avatarImg : ''}
                <div class="message-content-area">
                    ${replyHTML}
                    ${!isSelf ? `<div class="message-sender-name" onclick="openProfile('${msg.sender}')">${msg.displayName || msg.sender} <span style="font-weight:400; font-size:0.6rem; color:#666;">${time}</span></div>` : ''}
                    <div class="bubble">
                        ${contentHTML}
                    </div>
                </div>
                ${isSelf ? avatarImg : ''}
            `;
        }
        
        // Reply Handler
        if (!isSystem) {
            div.ondblclick = () => setupReply(msg);
        }

        chatBox.appendChild(div);
    }

    function setupReply(msgObject) {
        currentReplyTo = msgObject;
        replyBar.style.display = 'flex';
        replyTargetName.innerText = msgObject.displayName || msgObject.sender;
        messageInput.focus();
    }

    function openDm(targetUsername) {
        if (targetUsername === currentUsername) return;
        currentChatMode = 'dm';
        currentDmTarget = targetUsername;
        unreadCounts[targetUsername] = 0; // Clear unread
        
        headerTitle.innerText = `@${targetUsername}`;
        chatBox.innerHTML = ''; // Clear Global chat

        // Load cached messages
        if (dmMessagesCache[targetUsername]) {
            dmMessagesCache[targetUsername].forEach(m => appendMessage(m));
        }

        renderDmList(); // Update UI highlighting
        toggleSidebarBtn.click(); // Close sidebar on mobile
    }

    function renderDmList(onlineUsers = []) {
        // Simple distinct list of people we've DMed or who DMed us
        const cachedUsers = Object.keys(dmMessagesCache);
        // Also include online users if you want, but usually DM list is distinct history
        // For simplicity, let's just show people we have history with + a button to return to global
        
        dmListEl.innerHTML = '';

        // Global Chat Button
        const globalBtn = document.createElement('div');
        globalBtn.className = `dm-item ${currentChatMode === 'global' ? 'active' : ''}`;
        globalBtn.innerText = "# global-chat";
        globalBtn.onclick = () => {
            currentChatMode = 'global';
            headerTitle.innerText = "The C&C Corp chat";
            chatBox.innerHTML = '';
            socket.emit('get-history'); // Re-fetch global history (or cache it locally)
            // Ideally we should have cached global history too, but for now reload it:
            location.reload(); // Lazy reload to get back global history cleanly
        };
        dmListEl.appendChild(globalBtn);

        cachedUsers.forEach(u => {
            const div = document.createElement('div');
            const unread = unreadCounts[u] ? `<span class="badge">${unreadCounts[u]}</span>` : '';
            div.className = `dm-item ${currentDmTarget === u && currentChatMode === 'dm' ? 'active' : ''}`;
            div.innerHTML = `@${u} ${unread}`;
            div.onclick = () => openDm(u);
            dmListEl.appendChild(div);
        });
    }

    function linkify(text) {
        // Basic URL replacer
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        return text.replace(urlRegex, '<a href="$1" target="_blank">$1</a>');
    }

    function openProfile(username) {
        window.location.href = `/profile.html?user=${username}`;
    }

    // --- EVENT LISTENERS ---
    
    sendBtn.onclick = sendMessage;
    
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') sendMessage();
    });

    uploadBtn.onclick = () => hiddenFileInput.click();
    
    hiddenFileInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        // Upload to server immediately to get URL (or stage base64)
        // For this app, let's upload to server endpoint /upload
        const formData = new FormData();
        formData.append('file', file);

        try {
            uploadBtn.innerText = "‚è≥";
            const res = await fetch('/upload', { method: 'POST', body: formData });
            const data = await res.json();
            
            if (data.url) {
                stagedImage = data.url;
                imagePreviewArea.style.display = 'flex';
                imagePreviewImg.src = stagedImage;
            }
        } catch (err) {
            alert("Upload failed");
        } finally {
            uploadBtn.innerText = "+";
        }
    };

    removeImageBtn.onclick = () => {
        stagedImage = null;
        imagePreviewArea.style.display = 'none';
        hiddenFileInput.value = '';
    };

    cancelReplyBtn.onclick = () => {
        currentReplyTo = null;
        replyBar.style.display = 'none';
    };

    toggleSidebarBtn.onclick = () => {
        dmSidebar.classList.toggle('open');
    };

    profileBtn.onclick = () => {
        window.location.href = `/profile.html?user=${currentUsername}`;
    };

    // --- SETTINGS MODAL ---
    settingsBtn.onclick = () => settingsModal.style.display = "block";
    closeSettings.onclick = () => settingsModal.style.display = "none";
    window.onclick = (event) => {
        if (event.target == settingsModal) settingsModal.style.display = "none";
    }
    
    btnCloakLauncher.onclick = () => {
        const win = window.open('about:blank', '_blank');
        if (win) {
            win.document.body.style.margin = '0';
            win.document.body.style.height = '100vh';
            const iframe = win.document.createElement('iframe');
            iframe.style.border = 'none';
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.margin = '0';
            iframe.src = window.location.href + '?mode=popup';
            win.document.body.appendChild(iframe);
        }
    };
    
    launchCustomWindowBtn.onclick = () => {
        window.open(window.location.href + '?mode=popup', 'ChatWindow', 'width=400,height=600');
    };
    
    btnBgUpload.onclick = () => bgUploadInput.click();
    bgUploadInput.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                document.body.style.backgroundImage = `url('${ev.target.result}')`;
                localStorage.setItem('custom_bg', ev.target.result);
            };
            reader.readAsDataURL(file);
        }
    };
    btnBgReset.onclick = () => {
        document.body.style.backgroundImage = 'none';
        localStorage.removeItem('custom_bg');
    };

    // --- VOICE CHAT (SIMPLE) ---
    // Note: Full WebRTC implementation requires STUN/TURN and peer management.
    // This is a placeholder/basic signaling setup.
    let localStream;
    let peers = {}; 
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    joinVcBtn.onclick = async () => {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            socket.emit('join-vc');
            joinVcBtn.style.display = 'none';
            leaveVcBtn.style.display = 'inline-block';
        } catch (e) {
            alert("Could not access microphone");
        }
    };

    leaveVcBtn.onclick = () => {
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        socket.emit('leave-vc');
        joinVcBtn.style.display = 'inline-block';
        leaveVcBtn.style.display = 'none';
        // Close peers
        Object.values(peers).forEach(p => p.close());
        peers = {};
    };

    socket.on('update-vc-list', (users) => {
        vcUserList.innerHTML = '';
        users.forEach(u => {
            const div = document.createElement('div');
            div.className = 'vc-user';
            div.innerText = `üîä ${u}`;
            vcUserList.appendChild(div);
        });
    });

    socket.on('vc-user-joined', async (socketId) => {
        if (!localStream) return;
        // Initiate peer connection
        const pc = new RTCPeerConnection(rtcConfig);
        peers[socketId] = pc;
        
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        
        pc.onicecandidate = event => {
            if (event.candidate) {
                socket.emit('signal', { target: socketId, signal: { candidate: event.candidate } });
            }
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit('signal', { target: socketId, signal: { sdp: offer } });
    });

    socket.on('signal', async (data) => {
        if (!localStream) return;
        const senderId = data.sender;
        
        if (!peers[senderId]) {
             const pc = new RTCPeerConnection(rtcConfig);
             peers[senderId] = pc;
             
             pc.ontrack = (e) => {
                 const audio = new Audio();
                 audio.srcObject = e.streams[0];
                 audio.play();
             };

             pc.onicecandidate = event => {
                if (event.candidate) {
                    socket.emit('signal', { target: senderId, signal: { candidate: event.candidate } });
                }
             };

             localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        }

        const pc = peers[senderId];
        const signal = data.signal;

        if (signal.sdp) {
            await pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
            if (signal.sdp.type === 'offer') {
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.emit('signal', { target: senderId, signal: { sdp: answer } });
            }
        } else if (signal.candidate) {
            await pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
        }
    });

</script>
</body>
</html>
