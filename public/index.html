<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple Chat App</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="chat-container">
        <div id="username-area">
            <button id="avatar-upload-btn" title="Set Avatar">
                <img id="current-avatar-preview" src="placeholder-avatar.png" alt="Avatar">
            </button>
            <h3>username:</h3>
            <input type="text" id="username-input" placeholder="whatr we callin ya">
            <button id="set-username-btn">Save</button>
        </div>

        <div id="online-users-area">
            <h4>whos online:</h4>
            <ul id="online-users-list"></ul>
        </div>
        
        <div id="messages"></div>

        <div id="message-input-area">
            <div id="image-preview-area" style="display:none;">
                <img id="image-preview" src="" alt="Image Preview">
                <button id="remove-image-btn">X</button>
            </div>
            <textarea id="message-input" placeholder="type type type..." rows="1"></textarea>
            <button id="file-upload-btn">üìÅ</button>
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <div id="right-panel">
        <h4 class="panel-title">other stuff</h4>
        <button id="launch-custom-window-btn" class="panel-btn">resizable window</button>

        <h4 class="panel-title">voice chat</h4>
        <button id="vc-btn-join" class="panel-btn">Join Call</button>
        <button id="vc-btn-mute" class="panel-btn" style="display: none;">Mute</button>
        <ul id="vc-user-list"></ul>
        <div id="audio-container" style="display:none;"></div>
    </div>
    
</div>

<script>
    // --- Popup Logic ---
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'popup') {
        document.getElementById('right-panel').style.display = 'none';
        document.getElementById('main-wrapper').style.maxWidth = '100%';
    }

    const socket = io();

    // --- DOM Elements ---
    const messagesDiv = document.getElementById('messages');
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const onlineUsersList = document.getElementById('online-users-list');
    const launchCustomWindowBtn = document.getElementById('launch-custom-window-btn');
    const avatarUploadBtn = document.getElementById('avatar-upload-btn');
    const currentAvatarPreview = document.getElementById('current-avatar-preview');
    const vcBtnJoin = document.getElementById('vc-btn-join');
    const vcBtnMute = document.getElementById('vc-btn-mute');
    const vcUserList = document.getElementById('vc-user-list');
    const audioContainer = document.getElementById('audio-container');

    let currentUsername = '';
    let currentAvatarBase64 = ''; 
    let lastMessageSender = ''; 
    let lastMessageTime = 0; 
    
    // --- WebRTC Variables ---
    let localStream = null;
    let peers = {}; 
    let isInVC = false;
    let audioCtx; 

    const rtcConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' }
        ]
    };

    // --- 1. Avatar & Username ---
    avatarUploadBtn.addEventListener('click', () => {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onloadend = () => {
                    currentAvatarBase64 = reader.result;
                    currentAvatarPreview.src = currentAvatarBase64; 
                    if (currentUsername) setUsername(currentUsername); 
                    localStorage.setItem('chatAvatar', currentAvatarBase64);
                };
                reader.readAsDataURL(file);
            }
        });
        fileInput.click();
    });

    document.addEventListener('DOMContentLoaded', () => {
        const storedUsername = localStorage.getItem('chatUsername');
        const storedAvatar = localStorage.getItem('chatAvatar');
        if (storedAvatar) { currentAvatarBase64 = storedAvatar; currentAvatarPreview.src = storedAvatar; }
        if (storedUsername) { usernameInput.value = storedUsername; setUsername(storedUsername); }
    });

    setUsernameBtn.addEventListener('click', () => {
        const username = usernameInput.value.trim();
        if (username) {
            localStorage.setItem('chatUsername', username);
            setUsername(username);
        }
    });
    
    function setUsername(username) {
        currentUsername = username;
        socket.emit('set-username', { username, avatar: currentAvatarBase64 || 'placeholder-avatar.png' }); 
        usernameInput.disabled = true;
        setUsernameBtn.disabled = true;
    }

    // --- 2. Chat Logic ---
    function sendMessage() {
        let msg = messageInput.value.trim();
        if (!msg || !currentUsername) return; 
        socket.emit('chat-message', msg);
        messageInput.value = '';
    }
    sendButton.addEventListener('click', sendMessage);
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault(); sendMessage();
        }
    });
    
    function parseFormatting(text) {
        return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
            .replace(/~~(.*?)~~/g, '<del>$1</del>')
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>');
    }

    function displayMessage(messageObject) {
        let formattedMessage, messageAvatar, sender;
        if (typeof messageObject === 'string' || !messageObject.avatar) {
            formattedMessage = messageObject.text || messageObject; 
            messageAvatar = 'placeholder-avatar.png'; sender = null;
        } else {
            formattedMessage = messageObject.text;
            messageAvatar = messageObject.avatar; sender = messageObject.sender;
        }

        const messageEl = document.createElement('div');
        messageEl.classList.add('message');

        // Check for System Message
        const systemMatch = formattedMessage.match(/^\*\*(System|Announcement)\*\* (.*?) \[/);
        const privateMatch = formattedMessage.match(/^\*\*System\*\* \*\*\[PM/);

        if (privateMatch) {
            messageEl.classList.add('private-message');
            messageEl.innerHTML = parseFormatting(formattedMessage.split(']**: ')[1].replace('**', ''));
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return;
        }

        if (systemMatch) {
            messageEl.classList.add('system-message');
            // Extract just the text content, ignore timestamp for system
            let content = formattedMessage.substring(formattedMessage.indexOf('** ') + 3, formattedMessage.lastIndexOf('['));
            messageEl.innerHTML = parseFormatting(content);
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return;
        }

        // Regular Message Parsing
        const fullMatch = formattedMessage.match(/\*\*(.*?)\*\*: (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);
        if (!fullMatch) return; 

        const finalSender = sender || fullMatch[1];
        const messageText = fullMatch[2];
        const timeString = fullMatch[3]; 
        const isUserMessage = (finalSender === currentUsername);

        if (isUserMessage) messageEl.classList.add('user-message');
        else messageEl.classList.add('other-message');

        // Grouping
        let showAvatar = true;
        if (lastMessageSender === finalSender) {
            showAvatar = false;
            messageEl.classList.add('grouped-message');
        }
        lastMessageSender = finalSender;

        // Avatar
        if (!isUserMessage) {
            if (showAvatar) {
                const img = document.createElement('img');
                img.classList.add('avatar'); img.src = messageAvatar;
                messageEl.appendChild(img);
            } else {
                const spacer = document.createElement('div');
                spacer.classList.add('avatar-spacer');
                messageEl.appendChild(spacer);
            }
        }

        const contentArea = document.createElement('div');
        contentArea.classList.add('message-content-area');

        if (showAvatar && !isUserMessage) {
            const uDiv = document.createElement('div');
            uDiv.classList.add('message-username');
            uDiv.innerText = finalSender;
            contentArea.appendChild(uDiv);
        }

        const contentWrapper = document.createElement('div');
        contentWrapper.classList.add('message-content-wrapper');

        const bubble = document.createElement('div');
        bubble.classList.add('bubble-content');
        bubble.innerHTML = parseFormatting(messageText);
        
        const time = document.createElement('div');
        time.classList.add('message-time');
        time.innerText = timeString;

        contentWrapper.appendChild(bubble);
        contentWrapper.appendChild(time);
        
        contentArea.appendChild(contentWrapper);
        messageEl.appendChild(contentArea);
        messagesDiv.appendChild(messageEl);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // ======================================================
    // --- 3. VOICE CHAT CORE (The missing part!) ---
    // ======================================================
    
    // Monitors volume and toggles the .speaking class
    function attachSpeakingDetector(stream, userId) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const source = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        source.connect(analyser);
        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        function checkVolume() {
            if (!isInVC) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            const average = sum / dataArray.length;

            // Update UI
            const userLi = document.getElementById(`vc-user-${userId}`);
            if (userLi) {
                if (average > 10) userLi.classList.add('speaking');
                else userLi.classList.remove('speaking');
            }
            requestAnimationFrame(checkVolume);
        }
        checkVolume();
    }

    async function startVC() {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();

            // Light up my own avatar when I speak
            attachSpeakingDetector(localStream, socket.id);

            isInVC = true;
            vcBtnJoin.textContent = 'Leave Call';
            vcBtnJoin.style.backgroundColor = 'var(--color-vc-red)';
            vcBtnMute.style.display = 'block';
            socket.emit('vc-join', true);

        } catch (err) {
            console.error(err);
            alert('Microphone access denied.');
        }
    }

    function leaveVC() {
        socket.emit('vc-join', false);
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        Object.keys(peers).forEach(key => { peers[key].close(); delete peers[key]; });
        isInVC = false;
        vcBtnJoin.textContent = 'Join Call';
        vcBtnJoin.style.backgroundColor = '';
        vcBtnMute.style.display = 'none';
    }

    // Create P2P Connection
    function createPeerConnection(targetId, initiator) {
        if (peers[targetId]) return;
        const peer = new RTCPeerConnection(rtcConfig);
        peers[targetId] = peer;

        if (localStream) localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

        peer.ontrack = (event) => {
            let audioEl = document.getElementById(`audio-${targetId}`);
            if (!audioEl) {
                audioEl = document.createElement('audio');
                audioEl.id = `audio-${targetId}`;
                audioEl.autoplay = true;
                audioContainer.appendChild(audioEl);
            }
            audioEl.srcObject = event.streams[0];
            attachSpeakingDetector(event.streams[0], targetId);
        };

        peer.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('signal', { target: targetId, signal: { type: 'candidate', candidate: event.candidate } });
            }
        };

        if (initiator) {
            peer.createOffer().then(offer => peer.setLocalDescription(offer))
                .then(() => socket.emit('signal', { target: targetId, signal: { type: 'offer', sdp: peer.localDescription } }));
        }
        return peer;
    }

    // VC Socket Listeners
    socket.on('vc-user-joined', (id) => { if (isInVC) createPeerConnection(id, true); });
    socket.on('vc-user-left', (id) => { 
        if (peers[id]) { peers[id].close(); delete peers[id]; }
        const el = document.getElementById(`audio-${id}`); if (el) el.remove();
    });
    
    socket.on('signal', async ({ sender, signal }) => {
        if (!isInVC) return;
        let peer = peers[sender];
        if (!peer) peer = createPeerConnection(sender, false);

        if (signal.type === 'offer') {
            await peer.setRemoteDescription(new RTCSessionDescription(signal.sdp));
            const answer = await peer.createAnswer();
            await peer.setLocalDescription(answer);
            socket.emit('signal', { target: sender, signal: { type: 'answer', sdp: answer } });
        } else if (signal.type === 'answer') {
            await peer.setRemoteDescription(new RTCSessionDescription(signal.sdp));
        } else if (signal.type === 'candidate') {
            try { await peer.addIceCandidate(new RTCIceCandidate(signal.candidate)); } catch(e){}
        }
    });

    vcBtnJoin.addEventListener('click', () => {
        if (!currentUsername) return alert("Set username first.");
        isInVC ? leaveVC() : startVC();
    });

    vcBtnMute.addEventListener('click', () => {
        if (!localStream) return;
        const track = localStream.getAudioTracks()[0];
        track.enabled = !track.enabled;
        vcBtnMute.textContent = track.enabled ? 'Mute' : 'Unmute';
        socket.emit('vc-mute-toggle', !track.enabled);
    });

    // VC List Update
    socket.on('vc-user-list-update', (users) => {
        vcUserList.innerHTML = '';
        users.forEach(u => {
            const li = document.createElement('li');
            li.id = `vc-user-${u.id}`; // Crucial for green circle finding
            const img = document.createElement('img');
            img.classList.add('avatar', 'list-avatar');
            img.src = u.avatar;
            li.appendChild(img);
            li.appendChild(document.createTextNode(u.username));
            if (u.isMuted) li.innerHTML += ' <span style="color:var(--color-vc-red)">üîá</span>';
            vcUserList.appendChild(li);
        });
    });

    // --- Standard Socket Listeners ---
    socket.on('chat-message', displayMessage);
    socket.on('history', (h) => { messagesDiv.innerHTML = ''; h.forEach(displayMessage); });
    socket.on('user-list-update', (users) => {
        onlineUsersList.innerHTML = '';
        users.forEach(u => {
            const li = document.createElement('li');
            const img = document.createElement('img');
            img.classList.add('avatar', 'list-avatar'); img.src = u.avatar;
            li.appendChild(img); li.appendChild(document.createTextNode(u.username));
            onlineUsersList.appendChild(li);
        });
    });
    
    if (launchCustomWindowBtn) launchCustomWindowBtn.addEventListener('click', () => {
        window.open(`${window.location.href.split('?')[0]}?mode=popup`, '_blank', 'width=200,height=700,resizable=yes');
    });

</script>
</body>
</html>
