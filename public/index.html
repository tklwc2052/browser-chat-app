<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simple Chat App</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="chat-container">
        <div id="username-area">
            <button id="avatar-upload-btn" title="Set Avatar (Click to Upload)">
                <img id="current-avatar-preview" src="placeholder-avatar.png" alt="Avatar">
            </button>
            <h3>username:</h3>
            <input type="text" id="username-input" placeholder="whatr we callin ya">
            <button id="set-username-btn">Save</button>
        </div>

        <div id="online-users-area">
            <h4>whos online:</h4>
            <ul id="online-users-list">
            </ul>
        </div>
        
        <div id="messages">
        </div>

        <div id="message-input-area">
            <div id="image-preview-area" style="display:none;">
                <img id="image-preview" src="" alt="Image Preview">
                <button id="remove-image-btn">X</button>
            </div>
            <textarea id="message-input" placeholder="type type type..." rows="1"></textarea>
            <button id="file-upload-btn" title="File Upload (Not implemented)">
                üìÅ
            </button>
            <button id="send-button">Send</button>
        </div>
    </div>
    
    <div id="right-panel">
        <h4 class="panel-title">other stuff</h4>
        <button id="launch-custom-window-btn" class="panel-btn">resizable window</button>
        <p class="panel-hint">for a dedicated status/chat window.</p>

        <h4 class="panel-title">voice chat</h4>
        <button id="vc-btn-join" class="panel-btn">Join Call</button>
        <button id="vc-btn-mute" class="panel-btn" style="display: none;">Mute</button>
        <ul id="vc-user-list">
        </ul>
        <div id="audio-container" style="display:none;"></div>
    </div>
    
</div>

<script>
    // --- 0. Popup Mode Check ---
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'popup') {
        const mainWrapper = document.getElementById('main-wrapper');
        const rightPanel = document.getElementById('right-panel');
        const chatContainer = document.getElementById('chat-container');
        
        const messageInputArea = document.getElementById('message-input-area');
        const fileUploadBtn = document.getElementById('file-upload-btn');
        const sendButton = document.getElementById('send-button');

        if (mainWrapper) {
            mainWrapper.style.gap = '0';
            mainWrapper.style.maxWidth = '150px'; 
        }
        if (rightPanel) {
            rightPanel.style.display = 'none';
        }
        if (chatContainer) {
            chatContainer.style.maxWidth = '100%';
        }

        if (messageInputArea) {
            messageInputArea.style.flexDirection = 'column';
            messageInputArea.style.gap = '5px';
        }
        if (fileUploadBtn) {
            fileUploadBtn.style.width = '100%';
            fileUploadBtn.style.alignSelf = 'stretch';
        }
        if (sendButton) {
            sendButton.style.width = '100%';
            sendButton.style.alignSelf = 'stretch';
        }
    }

    const socket = io();

    // --- DOM Elements ---
    const messagesDiv = document.getElementById('messages');
    const usernameInput = document.getElementById('username-input');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const onlineUsersList = document.getElementById('online-users-list');
    const launchCustomWindowBtn = document.getElementById('launch-custom-window-btn');
    
    // AVATAR ELEMENTS
    const avatarUploadBtn = document.getElementById('avatar-upload-btn');
    const currentAvatarPreview = document.getElementById('current-avatar-preview');

    // VC ELEMENTS
    const vcBtnJoin = document.getElementById('vc-btn-join');
    const vcBtnMute = document.getElementById('vc-btn-mute');
    const vcUserList = document.getElementById('vc-user-list');
    const audioContainer = document.getElementById('audio-container');


    let currentUsername = '';
    let currentAvatarBase64 = ''; 
    let lastMessageSender = ''; 
    let lastMessageTime = 0; 
    
    // --- WebRTC State Variables ---
    let localStream = null;
    let peers = {}; // Object to store RTCPeerConnections: { userId: connection }
    let isInVC = false;

    // ICE Configuration (Stun servers help you punch through firewalls)
    const rtcConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };

    // --- 1. Utility Function to Handle Formatting ---
    function parseFormatting(text) {
        let formattedText = text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        formattedText = formattedText.replace(/~~(.*?)~~/g, '<del>$1</del>');
        formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        formattedText = formattedText.replace(/__(.*?)\b__/g, '<u>$1</u>'); 
        formattedText = formattedText.replace(/\*(.*?)\*/g, '<em>$1</em>');
        
        formattedText = formattedText.replace(/&lt;del&gt;/g, '<del>').replace(/&lt;\/del&gt;/g, '</del>');
        formattedText = formattedText.replace(/&lt;strong&gt;/g, '<strong>').replace(/&lt;\/strong&gt;/g, '</strong>');
        formattedText = formattedText.replace(/&lt;u&gt;/g, '<u>').replace(/&lt;\/u&gt;/g, '</u>');
        formattedText = formattedText.replace(/&lt;em&gt;/g, '<em>').replace(/&lt;\/em&gt;/g, '</em>');

        return formattedText;
    }

    // --- 2. Avatar Selection and Conversion ---
    avatarUploadBtn.addEventListener('click', () => {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onloadend = () => {
                    currentAvatarBase64 = reader.result;
                    currentAvatarPreview.src = currentAvatarBase64; 
                    
                    if (currentUsername) {
                        setUsername(currentUsername); 
                    }
                    localStorage.setItem('chatAvatar', currentAvatarBase64);
                };
                reader.readAsDataURL(file);
            }
        });
        
        fileInput.click();
    });


    // --- 3. Username Handling ---
    document.addEventListener('DOMContentLoaded', () => {
        const storedUsername = localStorage.getItem('chatUsername');
        const storedAvatar = localStorage.getItem('chatAvatar');

        if (storedAvatar) {
            currentAvatarBase64 = storedAvatar;
            currentAvatarPreview.src = storedAvatar;
        } else {
            currentAvatarPreview.src = 'placeholder-avatar.png';
        }

        if (storedUsername) {
            usernameInput.value = storedUsername;
            setUsername(storedUsername);
        }
    });

    setUsernameBtn.addEventListener('click', () => {
        const username = usernameInput.value.trim();
        if (username) {
            localStorage.setItem('chatUsername', username);
            if (currentAvatarBase64) {
                 localStorage.setItem('chatAvatar', currentAvatarBase64);
            }
            setUsername(username);
        } else {
            console.warn('Please enter a username.');
        }
    });
    
    function setUsername(username) {
        currentUsername = username;
        socket.emit('set-username', { 
            username: currentUsername, 
            avatar: currentAvatarBase64 || 'placeholder-avatar.png'
        }); 
        usernameInput.disabled = true;
        setUsernameBtn.disabled = true;
        usernameInput.placeholder = 'Username set!';
        messageInput.focus();
    }

    // --- 4. Message Sending ---
    function sendMessage() {
        let msg = messageInput.value.trim();
        if (!msg || !currentUsername) return; 

        socket.emit('chat-message', msg);
        messageInput.value = '';
    }

    sendButton.addEventListener('click', sendMessage);

    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // --- 5. Message Display Helper ---
    function displayMessage(messageObject) {
        if (typeof messageObject === 'string' || messageObject.avatar === null) {
            var formattedMessage = messageObject.text || messageObject; 
            var messageAvatar = null;
            var sender = null;
        } else {
            var formattedMessage = messageObject.text;
            var messageAvatar = messageObject.avatar;
            var sender = messageObject.sender;
        }

        const messageEl = document.createElement('div');
        messageEl.classList.add('message');

        const fullMatch = formattedMessage.match(/\*\*(.*?)\*\*: (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);

        // System/Announcement
        if (!fullMatch) {
            const systemMatch = formattedMessage.match(/\*\*(.*?)\*\* (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);
            lastMessageTime = 0; 
            lastMessageSender = ''; 

            if (systemMatch) {
                messageEl.classList.add('system-message');
                const systemText = systemMatch[2];
                if (systemText.startsWith('**[PM from') || systemText.startsWith('**[PM to')) {
                    messageEl.classList.add('private-message');
                    let pmContent = systemText.replace(/\*\*(.*?)\*\*/, '$1'); 
                    messageEl.innerHTML = parseFormatting(`<u>${pmContent}</u>`); 
                    messagesDiv.appendChild(messageEl);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    return; 
                }
                messageEl.innerHTML = parseFormatting(systemText);
                messagesDiv.appendChild(messageEl);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                return;
            }
            messageEl.classList.add('system-message');
            messageEl.innerHTML = parseFormatting(formattedMessage);
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return;
        }
        
        const extractedSender = fullMatch[1];
        const messageText = fullMatch[2];
        const timeString = fullMatch[3]; 

        const finalSender = sender || extractedSender;
        const finalAvatar = messageAvatar || 'placeholder-avatar.png'; 
        const isUserMessage = (finalSender === currentUsername);
        let showAvatar = true;
        let showUsername = true; 

        let currentTimeInMinutes = 0;
        const timeParts = timeString.match(/(\d{1,2}):(\d{2}) (AM|PM)/);
        if (timeParts) {
            let hours = parseInt(timeParts[1]);
            const minutes = parseInt(timeParts[2]);
            const isPM = timeParts[3] === 'PM';
            if (isPM && hours !== 12) hours += 12;
            if (!isPM && hours === 12) hours = 0;
            currentTimeInMinutes = hours * 60 + minutes;
        }

        if (isUserMessage) {
            messageEl.classList.add('user-message');
            showUsername = false; 
        } else {
            messageEl.classList.add('other-message');
        }

        const shouldGroup = (lastMessageSender === finalSender) && (currentTimeInMinutes - lastMessageTime) < 1;

        if (shouldGroup) {
            showAvatar = false; 
            showUsername = false; 
            messageEl.classList.add('grouped-message');
            const previousMessageEl = messagesDiv.lastChild;
            if (previousMessageEl && !previousMessageEl.classList.contains('system-message')) {
                const prevContentWrapper = previousMessageEl.querySelector('.message-content-wrapper');
                if (prevContentWrapper) {
                    const prevTimeSpan = prevContentWrapper.querySelector('.message-time');
                    if (prevTimeSpan) prevTimeSpan.remove();
                }
            }
        } 

        lastMessageSender = finalSender;
        lastMessageTime = currentTimeInMinutes;
        
        if (!isUserMessage) {
            if (showAvatar) {
                const avatarImg = document.createElement('img');
                avatarImg.classList.add('avatar');
                avatarImg.src = finalAvatar;
                messageEl.appendChild(avatarImg);
            } else {
                const spacer = document.createElement('div');
                spacer.classList.add('avatar-spacer');
                messageEl.appendChild(spacer);
            }
        }
        
        const contentArea = document.createElement('div');
        contentArea.classList.add('message-content-area');
        
        if (showUsername && !isUserMessage) {
            const usernameDiv = document.createElement('div');
            usernameDiv.classList.add('message-username');
            usernameDiv.innerHTML = `<strong>${finalSender}</strong><span class="username-separator">:</span>`;
            contentArea.appendChild(usernameDiv);
        }

        const contentWrapper = document.createElement('div');
        contentWrapper.classList.add('message-content-wrapper');
        
        const bubbleContent = document.createElement('span');
        bubbleContent.classList.add('bubble-content');
        bubbleContent.innerHTML = parseFormatting(messageText);
        contentWrapper.appendChild(bubbleContent); 
        
        const timeSpan = document.createElement('span');
        timeSpan.classList.add('message-time');
        timeSpan.textContent = timeString; 
        contentWrapper.appendChild(timeSpan); 
        
        contentArea.appendChild(contentWrapper);
        messageEl.appendChild(contentArea);
        
        messagesDiv.appendChild(messageEl);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }


    // ======================================================
    // --- 6. VOICE CHAT LOGIC (WEBRTC IMPLEMENTATION) ---
    // ======================================================
    
    async function startVC() {
        try {
            // 1. Get Microphone Access
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            
            // 2. Update UI
            isInVC = true;
            vcBtnJoin.textContent = 'Leave Call';
            vcBtnJoin.style.backgroundColor = 'var(--color-vc-red)';
            vcBtnMute.style.display = 'block';
            vcBtnMute.textContent = 'Mute';
            vcBtnMute.classList.remove('active');
            
            // 3. Notify Server
            socket.emit('vc-join', true);

        } catch (err) {
            console.error('Error accessing microphone:', err);
            alert('Could not access microphone. Please ensure you have granted permission.');
        }
    }

    function leaveVC() {
        // 1. Notify Server
        socket.emit('vc-join', false);
        
        // 2. Stop all local tracks
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }

        // 3. Close all peer connections
        Object.keys(peers).forEach(key => {
            peers[key].close();
            delete peers[key];
        });
        
        // 4. Remove all audio elements
        audioContainer.innerHTML = '';

        // 5. Update UI
        isInVC = false;
        vcBtnJoin.textContent = 'Join Call';
        vcBtnJoin.style.backgroundColor = 'var(--color-accent-blue)';
        vcBtnMute.style.display = 'none';
    }

    // --- Trigger WebRTC Connection ---
    function createPeerConnection(targetId, initiator) {
        if (peers[targetId]) return; // Already connected

        const peer = new RTCPeerConnection(rtcConfig);
        peers[targetId] = peer;

        // Add local stream to this connection
        if (localStream) {
            localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
        }

        // Handle receiving remote stream
        peer.ontrack = (event) => {
            let audioEl = document.getElementById(`audio-${targetId}`);
            if (!audioEl) {
                audioEl = document.createElement('audio');
                audioEl.id = `audio-${targetId}`;
                audioEl.autoplay = true;
                audioContainer.appendChild(audioEl);
            }
            audioEl.srcObject = event.streams[0];
        };

        // Handle ICE candidates (Network info)
        peer.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('signal', {
                    target: targetId,
                    signal: { type: 'candidate', candidate: event.candidate }
                });
            }
        };

        // If we are the initiator (the one who just joined), create an Offer
        if (initiator) {
            peer.createOffer()
                .then(offer => peer.setLocalDescription(offer))
                .then(() => {
                    socket.emit('signal', {
                        target: targetId,
                        signal: { type: 'offer', sdp: peer.localDescription }
                    });
                })
                .catch(err => console.error('Error creating offer:', err));
        }
        
        return peer;
    }

    // --- Socket Listeners for WebRTC ---

    // A. Someone joined AFTER us -> We initiate call
    socket.on('vc-user-joined', (newUserId) => {
        if (isInVC) {
            createPeerConnection(newUserId, true); // true = initiator
        }
    });

    // B. Someone left -> Clean up
    socket.on('vc-user-left', (userId) => {
        if (peers[userId]) {
            peers[userId].close();
            delete peers[userId];
        }
        const audioEl = document.getElementById(`audio-${userId}`);
        if (audioEl) audioEl.remove();
    });

    // C. Signal Routing (Offer/Answer/Candidate)
    socket.on('signal', async ({ sender, signal }) => {
        if (!isInVC) return;

        // Ensure peer connection exists
        let peer = peers[sender];
        if (!peer) {
            peer = createPeerConnection(sender, false); // false = receiver
        }

        if (signal.type === 'offer') {
            // 1. Receive Offer
            await peer.setRemoteDescription(new RTCSessionDescription(signal.sdp));
            // 2. Create Answer
            const answer = await peer.createAnswer();
            await peer.setLocalDescription(answer);
            // 3. Send Answer
            socket.emit('signal', {
                target: sender,
                signal: { type: 'answer', sdp: answer }
            });
        } 
        else if (signal.type === 'answer') {
            // Receive Answer
            await peer.setRemoteDescription(new RTCSessionDescription(signal.sdp));
        } 
        else if (signal.type === 'candidate') {
            // Add ICE Candidate
            try {
                await peer.addIceCandidate(new RTCIceCandidate(signal.candidate));
            } catch (e) {
                console.error('Error adding received ice candidate', e);
            }
        }
    });


    // --- VC Button Event Listeners ---
    vcBtnJoin.addEventListener('click', () => {
        if (!currentUsername) {
            alert("Please set a username first to join VC.");
            return;
        }
        if (!isInVC) {
            startVC();
        } else {
            leaveVC();
        }
    });

    vcBtnMute.addEventListener('click', () => {
        if (!localStream) return;
        
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled; // Toggle actual hardware mute
            const isMuted = !audioTrack.enabled;
            
            vcBtnMute.textContent = isMuted ? 'Unmute' : 'Mute';
            if (isMuted) vcBtnMute.classList.add('active');
            else vcBtnMute.classList.remove('active');

            // Notify server for visual update only
            socket.emit('vc-mute-toggle', isMuted);
        }
    });

    socket.on('vc-user-list-update', (vcUsers) => {
        vcUserList.innerHTML = '';
        vcUsers.forEach(userData => {
            const li = document.createElement('li');
            
            const listAvatar = document.createElement('img');
            listAvatar.classList.add('avatar', 'list-avatar');
            listAvatar.src = userData.avatar || 'placeholder-avatar.png'; 
            li.appendChild(listAvatar);

            li.appendChild(document.createTextNode(userData.username));
            
            if (userData.isMuted) {
                const muteStatus = document.createElement('span');
                muteStatus.textContent = ' üîá';
                muteStatus.style.color = 'var(--color-vc-red)';
                li.appendChild(muteStatus);
            }
            
            if (userData.username === currentUsername) {
                li.style.fontWeight = 'bold';
                li.style.color = 'var(--color-text)'; 
            } else {
                li.style.fontWeight = 'normal';
                li.style.color = 'var(--color-accent-green)'; 
            }
            
            vcUserList.appendChild(li);
        });
    });


    // --- 7. Receiving Messages (History and Live) ---
    socket.on('history', (history) => {
        lastMessageTime = 0; 
        lastMessageSender = ''; 
        messagesDiv.innerHTML = ''; 
        history.forEach(msg => {
            displayMessage(msg); 
        });
        messagesDiv.scrollTop = messagesDiv.scrollHeight; 
    });

    socket.on('chat-message', (messageObject) => {
        displayMessage(messageObject);
    });

    socket.on('clear-chat', () => {
        messagesDiv.innerHTML = '';
    });

    // --- 8. Online User List Update ---
    socket.on('user-list-update', (users) => {
        onlineUsersList.innerHTML = '';
        users.forEach(userData => {
            const li = document.createElement('li');
            const listAvatar = document.createElement('img');
            listAvatar.classList.add('avatar', 'list-avatar');
            listAvatar.src = userData.avatar || 'placeholder-avatar.png'; 
            li.appendChild(listAvatar);
            li.appendChild(document.createTextNode(userData.username));
            onlineUsersList.appendChild(li);
        });
    });

    // --- 9. Launch Custom Window Logic ---
    if (launchCustomWindowBtn) {
         launchCustomWindowBtn.addEventListener('click', () => {
            const currentUrl = window.location.href.split('?')[0]; 
            const newUrl = `${currentUrl}?mode=popup`; 
            window.open(newUrl, '_blank', 'width=200,height=700,resizable=yes');
        });
    }
</script>
</body>
</html>
