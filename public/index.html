<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Chat App</title>
    <link rel="stylesheet" href="styles.css">
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>
    <div id="chat-container">
        <div id="username-area">
            <h3>Set Your Username:</h3>
            <input type="text" id="username-input" placeholder="Enter Username...">
            <button id="set-username-btn">Save</button>
        </div>

        <div id="online-users-area">
            <h4>Online Users:</h4>
            <ul id="online-users-list">
                </ul>
        </div>
        
        <div id="messages">
            </div>

        <div id="message-input-area">
            <textarea id="message-input" placeholder="Type your message here... (Press Enter to send)" rows="1"></textarea>
            <button id="file-upload-btn" title="File Upload (Not implemented)">
                üìÅ
            </button>
            <button id="send-button">Send</button>
        </div>
    </div>

    <script>
        const socket = io();

        // --- DOM Elements ---
        const messagesDiv = document.getElementById('messages');
        const usernameInput = document.getElementById('username-input');
        const setUsernameBtn = document.getElementById('set-username-btn');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const onlineUsersList = document.getElementById('online-users-list');

        let currentUsername = '';
        let lastUserMessageTime = 0; 
        let lastOtherMessageSender = ''; 

        // --- 1. Utility Function to Handle Formatting (No Change) ---
        function parseFormatting(text) {
            let formattedText = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            // Crossout: ~~text~~ with <del>text</del>
            formattedText = formattedText.replace(/~~(.*?)~~/g, '<del>$1</del>');
            
            // Bold: **text** with <strong>text</strong>
            formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Underline: __text__ with <u>text</u>
            formattedText = formattedText.replace(/__(.*?)__/g, '<u>$1</u>');
            
            // Slanted (Italics): *text* with <em>text</em>
            formattedText = formattedText.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // UNSANITIZE only the newly added HTML tags for rendering
            formattedText = formattedText.replace(/&lt;del&gt;/g, '<del>').replace(/&lt;\/del&gt;/g, '</del>');
            formattedText = formattedText.replace(/&lt;strong&gt;/g, '<strong>').replace(/&lt;\/strong&gt;/g, '</strong>');
            formattedText = formattedText.replace(/&lt;u&gt;/g, '<u>').replace(/&lt;\/u&gt;/g, '</u>');
            formattedText = formattedText.replace(/&lt;em&gt;/g, '<em>').replace(/&lt;\/em&gt;/g, '</em>');

            return formattedText;
        }

        // --- 2. Username Handling (No Change) ---
        
        document.addEventListener('DOMContentLoaded', () => {
            const storedUsername = localStorage.getItem('chatUsername');
            if (storedUsername) {
                usernameInput.value = storedUsername;
                setUsername(storedUsername);
            }
        });

        setUsernameBtn.addEventListener('click', () => {
            const username = usernameInput.value.trim();
            if (username) {
                localStorage.setItem('chatUsername', username);
                setUsername(username);
            } else {
                alert('Please enter a username.');
            }
        });
        
        function setUsername(username) {
            currentUsername = username;
            socket.emit('set-username', currentUsername); 
            usernameInput.disabled = true;
            setUsernameBtn.disabled = true;
            usernameInput.placeholder = 'Username set!';
            messageInput.focus();
        }

        // --- 3. Message Sending (No Change) ---

        function sendMessage() {
            let msg = messageInput.value.trim();
            if (!msg || !currentUsername) return; 

            socket.emit('chat-message', msg);
            messageInput.value = '';
        }

        sendButton.addEventListener('click', sendMessage);

        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // --- 4. Message Display Helper Function (CRITICAL Grouping Fix) ---
        function displayMessage(formattedMessage) {
            const messageEl = document.createElement('div');
            messageEl.classList.add('message');

            // Regex 1: Regular messages (HAS colon) **[User]**: [Message Text] [Time]
            const fullMatch = formattedMessage.match(/\*\*(.*?)\*\*: (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);

            // --- Handle System Messages/Announcements ---
            if (!fullMatch) {
                // Check for the System format: **[User]** [Message Text] [Time] (No colon)
                const systemMatch = formattedMessage.match(/\*\*(.*?)\*\* (.*?) \[(\d{1,2}:\d{2} (?:AM|PM))\]/);
                
                // CRITICAL: Reset trackers on system message
                lastUserMessageTime = 0; 
                lastOtherMessageSender = ''; 

                if (systemMatch) {
                    messageEl.classList.add('system-message');
                    const systemText = systemMatch[2];
                    messageEl.innerHTML = parseFormatting(systemText);
                    messagesDiv.appendChild(messageEl);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    return;
                }
                
                // Fallback for unparseable system messages/errors
                messageEl.classList.add('system-message');
                messageEl.innerHTML = parseFormatting(formattedMessage);
                messagesDiv.appendChild(messageEl);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    return;
            }
            
            // Extracted parts for REGULAR messages:
            const sender = fullMatch[1];
            const messageText = fullMatch[2];
            const timeString = fullMatch[3]; 

            // 1. Determine alignment class and grouping logic
            const isUserMessage = (sender === currentUsername);
            let showTime = true;
            let showUsername = true; 

            // --- Calculate Time in Minutes for Grouping ---
            let currentTimeInMinutes = 0;
            const timeParts = timeString.match(/(\d{1,2}):(\d{2}) (AM|PM)/);
            if (timeParts) {
                let hours = parseInt(timeParts[1]);
                const minutes = parseInt(timeParts[2]);
                const isPM = timeParts[3] === 'PM';
                
                if (isPM && hours !== 12) hours += 12;
                if (!isPM && hours === 12) hours = 0;
                currentTimeInMinutes = hours * 60 + minutes;
            }

            if (isUserMessage) {
                messageEl.classList.add('user-message');
                showUsername = false; 

                // User Message Grouping (Time only on the LAST message, Retroactive Fix)
                const previousMessageEl = messagesDiv.lastChild;
                
                if (previousMessageEl && 
                    previousMessageEl.classList.contains('user-message') && 
                    (currentTimeInMinutes - lastUserMessageTime) < 1) {
                        
                    showTime = false;
                    messageEl.classList.add('grouped-message'); 
                    
                    // === CRITICAL FINAL FIX: Robustly Remove the time from the PREVIOUS message ===
                    const prevContentWrapper = previousMessageEl.querySelector('.message-content-wrapper');

                    if (prevContentWrapper) {
                        // Find the time element within that wrapper and remove it
                        const prevTimeSpan = prevContentWrapper.querySelector('.message-time');
                        if (prevTimeSpan) {
                            prevTimeSpan.remove();
                            // console.log('Removed time from previous message.');
                        }
                    }
                    // ==============================================================================
                }

                lastUserMessageTime = currentTimeInMinutes;
                lastOtherMessageSender = ''; // Reset other sender tracker
                
            } else {
                // Other User Message Grouping (Name only on the FIRST message, time on the LAST message)
                
                // If the sender is the same AND time difference is < 1 minute
                if (lastOtherMessageSender === sender && (currentTimeInMinutes - lastUserMessageTime) < 1) {
                    showUsername = false; // Hide username
                    showTime = false; // Hide time (as we only want it on the very last)
                    messageEl.classList.add('grouped-message');
                } else {
                    // Reset time tracking when a new sender or gap is detected
                    lastUserMessageTime = 0; 
                }

                messageEl.classList.add('other-message');
                lastOtherMessageSender = sender; // Update the last sender tracker
                lastUserMessageTime = currentTimeInMinutes; // Track time for other users too
            }


            // --- 2. Assemble the Message Structure ---
            
            // 2a. Username (ONLY for other users, above the bubble)
            if (showUsername && !isUserMessage) {
                const usernameDiv = document.createElement('div');
                usernameDiv.classList.add('message-username');
                usernameDiv.innerHTML = `<strong>${sender}</strong><span class="username-separator">:</span>`;
                messageEl.appendChild(usernameDiv);
            }

            // 2b. Content Wrapper (Bubble + Time)
            const contentWrapper = document.createElement('div');
            contentWrapper.classList.add('message-content-wrapper');
            
            const bubbleContent = document.createElement('span');
            bubbleContent.classList.add('bubble-content');
            
            let contentHtml = parseFormatting(messageText); 

            bubbleContent.innerHTML = contentHtml;
            contentWrapper.appendChild(bubbleContent); 
            
            // 2c. Time Content
            if (showTime) {
                const timeSpan = document.createElement('span');
                timeSpan.classList.add('message-time');
                timeSpan.textContent = timeString; 
                contentWrapper.appendChild(timeSpan); 
            }

            // 3. Assemble the final message element
            messageEl.appendChild(contentWrapper);
            
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // --- 5. Receiving Messages (History and Live) ---
        
        socket.on('history', (history) => {
            // Reset trackers before starting the loop
            lastUserMessageTime = 0; 
            lastOtherMessageSender = ''; 
            messagesDiv.innerHTML = ''; 

            // Loop through history messages sequentially
            history.forEach(msg => {
                displayMessage(msg);
            });
            
            // DO NOT reset trackers again here. They should hold the state of the last history message.

            messagesDiv.scrollTop = messagesDiv.scrollHeight; 
        });

        socket.on('chat-message', (formattedMessage) => {
            displayMessage(formattedMessage);
        });

        socket.on('clear-chat', () => {
            messagesDiv.innerHTML = '';
        });

        // --- 6. Online User List Update (No Change) ---
        
        socket.on('user-list-update', (users) => {
            onlineUsersList.innerHTML = '';
            users.forEach(user => {
                const li = document.createElement('li');
                li.textContent = user;
                onlineUsersList.appendChild(li);
            });
        });
        
    </script>
</body>
