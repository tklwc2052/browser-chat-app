<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The C&C Corp chat</title>
<link rel="stylesheet" href="styles.css">
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="main-wrapper">

    <div id="dm-sidebar">
        <div id="dm-header">C&C Corp</div>
        <div id="dm-list">
            <div class="dm-user-card active" onclick="switchChannel(null)">
                <div class="dm-avatar-wrapper">
                    <div style="width:40px; height:40px; background:#5865F2; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">#</div>
                </div>
                <div class="dm-username">General Chat</div>
            </div>
            </div>
        
        <div id="username-area">
            <div id="username-controls">
                <img id="current-avatar-preview" src="placeholder-avatar.png">
                <span id="current-username-display">Loading...</span>
            </div>
            <button id="open-profile-btn">⚙️</button>
        </div>
    </div>

    <div id="chat-container">
        <div id="messages">
            <div class="motd-message">Welcome to the chat!</div>
        </div>

        <div id="message-input-area">
            <div id="reply-bar" style="display:none;">
                <span id="replying-to-text">Replying...</span>
                <button id="cancel-reply-btn">x</button>
            </div>
            <div id="image-preview-area" style="display:none;">
                <img id="image-preview" src="">
                <button id="remove-image-btn">X</button>
            </div>
            <div id="input-row">
                <button id="file-upload-btn">➕</button>
                <input type="file" id="file-input" accept="image/*" style="display: none;">
                <input type="text" id="message-input" placeholder="Message #general" autocomplete="off">
                <button id="send-button">➤</button>
            </div>
        </div>
    </div>

    <div id="right-panel">
        <div class="panel-top-group">
            <div class="panel-title">Voice Chat</div>
            <button id="vc-btn-join" class="panel-btn">Join Voice</button>
            <ul id="vc-user-list"></ul>
        </div>
        <div class="panel-bottom-group">
            <div class="panel-title">Online - <span id="online-count">0</span></div>
            <div id="online-user-list"></div>
        </div>
    </div>

</div>

<div id="ctx-menu">
    <div id="ctx-reply">Reply</div>
    <div id="ctx-edit">Edit Message</div>
    <div id="ctx-delete" style="color:#ff4444;">Delete Message</div>
    <div id="ctx-copy">Copy ID</div>
</div>

<div id="username-modal" style="display:flex; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999; justify-content:center; align-items:center;">
    <div style="background:#2f3136; padding:20px; border-radius:8px; text-align:center;">
        <h3>Enter Username</h3>
        <input type="text" id="username-input-modal" style="padding:10px; border-radius:4px; border:none;" placeholder="Username">
        <button id="username-submit-btn" style="padding:10px 20px; background:#5865F2; color:white; border:none; border-radius:4px; margin-left:10px; cursor:pointer;">Join</button>
    </div>
</div>

<script>
    const socket = io();
    let myUsername = localStorage.getItem('simplechat_username');
    let currentDMTarget = null; // null = General, string = username
    let replyToMsg = null;
    let imageToUpload = null;
    let peers = {}; // WebRTC Peers
    let localStream = null;

    // --- DOM ELEMENTS ---
    const messagesDiv = document.getElementById('messages');
    const msgInput = document.getElementById('message-input');
    const dmListDiv = document.getElementById('dm-list');
    const onlineListDiv = document.getElementById('online-user-list');
    const vcListDiv = document.getElementById('vc-user-list');
    const ctxMenu = document.getElementById('ctx-menu');
    
    // --- AUTH ---
    if(!myUsername) {
        document.getElementById('username-modal').style.display = 'flex';
    } else {
        document.getElementById('username-modal').style.display = 'none';
        socket.emit('set-username', { username: myUsername });
    }

    document.getElementById('username-submit-btn').onclick = () => {
        const val = document.getElementById('username-input-modal').value.trim();
        if(val) {
            myUsername = val;
            localStorage.setItem('simplechat_username', val);
            socket.emit('set-username', { username: val });
            document.getElementById('username-modal').style.display = 'none';
        }
    };

    // --- PROFILE ---
    document.getElementById('open-profile-btn').onclick = () => {
        window.location.href = '/profile';
    };
    socket.on('profile-info', (data) => {
        document.getElementById('current-username-display').innerText = data.displayName;
        document.getElementById('current-avatar-preview').src = data.avatar || 'placeholder-avatar.png';
        if(data.customBackground) document.body.style.backgroundImage = `url('${data.customBackground}')`;
    });

    // --- CHANNELS / DMS ---
    window.switchChannel = (targetUser) => {
        currentDMTarget = targetUser;
        
        // Update UI visuals
        document.querySelectorAll('.dm-user-card').forEach(el => el.classList.remove('active'));
        
        if(targetUser) {
            // Find user card and make active
            // (Simple selector logic for now)
            msgInput.placeholder = `Message @${targetUser}`;
            msgInput.style.backgroundColor = '#3c3847'; // Slight purple tint
        } else {
            // General
            document.querySelector('.dm-user-card').classList.add('active'); // First one is general
            msgInput.placeholder = `Message #general`;
            msgInput.style.backgroundColor = '';
        }
        
        // Note: Realistically we should filter messagesDiv here, but for now we just change sending behavior
    };

    // --- MESSAGING ---
    function sendMessage() {
        const text = msgInput.value.trim();
        if ((!text && !imageToUpload)) return;

        const payload = {
            text: text,
            image: imageToUpload,
            replyTo: replyToMsg,
            target: currentDMTarget // Send this to server
        };

        socket.emit('chat-message', payload);
        msgInput.value = '';
        cancelReply();
        cancelImage();
    }

    document.getElementById('send-button').onclick = sendMessage;
    msgInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') sendMessage(); });

    socket.on('chat-message', (msg) => {
        // Filter logic:
        // If it's a PM: Only show if I am sender OR I am receiver
        // If I am in General: Show General msgs. Hide PMs? 
        // For simplicity in this version: Show everything but style PMs differently
        
        appendMessage(msg);
    });

    function appendMessage(msg) {
        const div = document.createElement('div');
        div.className = `message ${msg.sender === myUsername ? 'user-message' : 'other-message'}`;
        div.id = `msg-${msg.id}`;
        
        if (msg.type === 'pm') div.style.borderLeft = "2px solid #9b59b6"; // Visual indicator for PMs

        // Avatar
        const avatarImg = document.createElement('img');
        avatarImg.className = 'message-avatar';
        avatarImg.src = msg.avatar || 'placeholder-avatar.png';
        
        // Content
        const contentDiv = document.createElement('div');
        contentDiv.className = 'bubble-content';
        
        // Name
        const nameDiv = document.createElement('div');
        nameDiv.style.fontSize = '0.75em';
        nameDiv.style.fontWeight = 'bold';
        nameDiv.style.marginBottom = '2px';
        nameDiv.style.color = msg.type === 'pm' ? '#d09ae6' : '#888';
        nameDiv.innerText = msg.senderDisplayName + (msg.type === 'pm' ? ' (Private)' : '');
        
        // Reply Preview
        if (msg.replyTo) {
            const replyDiv = document.createElement('div');
            replyDiv.className = 'reply-preview';
            replyDiv.innerText = `Replying to: ${msg.replyTo.text.substring(0, 30)}...`;
            contentDiv.appendChild(replyDiv);
        }

        // Image
        if (msg.image) {
            const img = document.createElement('img');
            img.src = msg.image;
            img.className = 'message-image';
            img.onclick = () => window.open(msg.image, '_blank');
            contentDiv.appendChild(img);
        }

        // Text
        const textSpan = document.createElement('div');
        textSpan.className = 'msg-text';
        textSpan.innerText = msg.text;
        
        // Edited Tag
        if (msg.isEdited) {
            const editTag = document.createElement('span');
            editTag.style.fontSize = '0.7em';
            editTag.style.color = '#aaa';
            editTag.innerText = ' (edited)';
            textSpan.appendChild(editTag);
        }

        contentDiv.appendChild(nameDiv);
        contentDiv.appendChild(textSpan);
        
        if (msg.sender === myUsername) {
            div.appendChild(contentDiv);
            div.appendChild(avatarImg);
        } else {
            div.appendChild(avatarImg);
            div.appendChild(contentDiv);
        }

        // Context Menu Event
        div.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showContextMenu(e, msg);
        });

        messagesDiv.appendChild(div);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // --- CONTEXT MENU (EDIT / DELETE) ---
    let ctxTargetMsg = null;
    function showContextMenu(e, msg) {
        ctxTargetMsg = msg;
        ctxMenu.style.display = 'block';
        ctxMenu.style.left = `${e.pageX}px`;
        ctxMenu.style.top = `${e.pageY}px`;
        
        // Only show edit/delete if it's my message
        const isMine = msg.sender === myUsername;
        document.getElementById('ctx-edit').style.display = isMine ? 'block' : 'none';
        document.getElementById('ctx-delete').style.display = isMine ? 'block' : 'none';
    }

    document.addEventListener('click', () => { ctxMenu.style.display = 'none'; });

    document.getElementById('ctx-delete').onclick = () => {
        if(ctxTargetMsg) socket.emit('delete-message', ctxTargetMsg.id);
    };

    document.getElementById('ctx-edit').onclick = () => {
        if(ctxTargetMsg) {
            const newText = prompt("Edit message:", ctxTargetMsg.text);
            if(newText !== null) socket.emit('edit-message', { id: ctxTargetMsg.id, newText });
        }
    };
    
    document.getElementById('ctx-reply').onclick = () => {
        if(ctxTargetMsg) {
            replyToMsg = ctxTargetMsg;
            document.getElementById('reply-bar').style.display = 'flex';
            document.getElementById('replying-to-text').innerText = `Replying to ${ctxTargetMsg.senderDisplayName}`;
            msgInput.focus();
        }
    };

    socket.on('message-deleted', (id) => {
        const el = document.getElementById(`msg-${id}`);
        if(el) el.remove();
    });

    socket.on('message-edited', ({ id, text }) => {
        const el = document.getElementById(`msg-${id}`);
        if(el) {
            const textEl = el.querySelector('.msg-text');
            if(textEl) {
                textEl.innerText = text;
                const tag = document.createElement('span');
                tag.style.fontSize='0.7em'; tag.style.color='#aaa'; tag.innerText=' (edited)';
                textEl.appendChild(tag);
            }
        }
    });

    // --- SIDEBAR LIST ---
    socket.on('sidebar-user-list', (list) => {
        // Clear except General
        const generalBtn = dmListDiv.firstElementChild;
        dmListDiv.innerHTML = '';
        dmListDiv.appendChild(generalBtn);
        
        list.forEach(u => {
            if(u.username === myUsername) return; // Don't show self
            
            const div = document.createElement('div');
            div.className = 'dm-user-card';
            div.onclick = () => switchChannel(u.username);
            
            const avWrap = document.createElement('div');
            avWrap.className = 'dm-avatar-wrapper';
            
            const img = document.createElement('img');
            img.src = u.avatar || 'placeholder-avatar.png';
            
            const status = document.createElement('div');
            status.className = `status-bubble ${u.online ? 'status-online' : 'status-offline'}`;
            
            avWrap.appendChild(img);
            avWrap.appendChild(status);
            
            const name = document.createElement('div');
            name.className = 'dm-username';
            name.innerText = u.displayName;
            
            div.appendChild(avWrap);
            div.appendChild(name);
            dmListDiv.appendChild(div);
        });
    });

    // --- FILE UPLOAD ---
    const fileBtn = document.getElementById('file-upload-btn');
    const fileInput = document.getElementById('file-input');
    fileBtn.onclick = () => fileInput.click();
    
    fileInput.onchange = async () => {
        const file = fileInput.files[0];
        if(!file) return;
        
        // Optimistic Preview
        document.getElementById('image-preview-area').style.display = 'flex';
        document.getElementById('image-preview').src = 'loading.gif'; // Or spinner

        const formData = new FormData();
        formData.append('file', file);
        
        try {
            const res = await fetch('/upload', { method: 'POST', body: formData });
            const data = await res.json();
            if(data.url) {
                imageToUpload = data.url;
                document.getElementById('image-preview').src = data.url;
            }
        } catch(e) { console.error(e); }
    };

    function cancelImage() {
        imageToUpload = null;
        document.getElementById('image-preview-area').style.display = 'none';
        fileInput.value = '';
    }
    document.getElementById('remove-image-btn').onclick = cancelImage;
    document.getElementById('cancel-reply-btn').onclick = cancelReply;
    function cancelReply() {
        replyToMsg = null;
        document.getElementById('reply-bar').style.display = 'none';
    }

    // --- VOICE CHAT (RAW WEBRTC) ---
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    let isVcJoined = false;

    document.getElementById('vc-btn-join').onclick = async () => {
        if(isVcJoined) {
            leaveVoice();
        } else {
            await joinVoice();
        }
    };

    async function joinVoice() {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            socket.emit('join-vc');
            isVcJoined = true;
            document.getElementById('vc-btn-join').innerText = "Leave Voice";
            document.getElementById('vc-btn-join').style.backgroundColor = '#dc3545';
        } catch(e) {
            alert("Could not access microphone.");
        }
    }

    function leaveVoice() {
        socket.emit('leave-vc');
        if(localStream) localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        isVcJoined = false;
        document.getElementById('vc-btn-join').innerText = "Join Voice";
        document.getElementById('vc-btn-join').style.backgroundColor = '#23a559';
        // Close all peers
        Object.values(peers).forEach(p => p.close());
        peers = {};
    }

    // When someone else joins, we call them
    socket.on('vc-user-joined', async (userId) => {
        if(!isVcJoined) return;
        createPeer(userId, true);
    });

    socket.on('vc-user-left', (userId) => {
        if(peers[userId]) {
            peers[userId].close();
            delete peers[userId];
        }
    });

    socket.on('signal', async ({ sender, signal }) => {
        if(!isVcJoined) return;
        if(!peers[sender]) createPeer(sender, false);
        try {
            await peers[sender].setRemoteDescription(new RTCSessionDescription(signal));
            if(signal.type === 'offer') {
                const answer = await peers[sender].createAnswer();
                await peers[sender].setLocalDescription(answer);
                socket.emit('signal', { target: sender, signal: peers[sender].localDescription });
            }
        } catch(e) { console.error(e); }
    });

    socket.on('vc-user-list-update', (list) => {
        vcListDiv.innerHTML = '';
        list.forEach(u => {
            const li = document.createElement('li');
            li.innerText = u.displayName;
            vcListDiv.appendChild(li);
        });
    });

    function createPeer(targetId, initiator) {
        const pc = new RTCPeerConnection(rtcConfig);
        peers[targetId] = pc;

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('signal', { target: targetId, signal: { type: 'candidate', candidate: event.candidate } });
            }
        };
        
        // Handle incoming audio
        pc.ontrack = (event) => {
            const audio = new Audio();
            audio.srcObject = event.streams[0];
            audio.play();
        };

        if (initiator) {
            pc.createOffer().then(offer => {
                pc.setLocalDescription(offer);
                socket.emit('signal', { target: targetId, signal: offer });
            });
        }
    }

    // Re-handling candidates specifically
    // Note: The simple signal handler above tries to handle everything. 
    // Ideally, we split 'offer'/'answer' from 'candidate'.
    // Refined Signal Handler:
    socket.off('signal'); // Remove previous to avoid dupes
    socket.on('signal', async ({ sender, signal }) => {
        if(!isVcJoined) return;
        
        if(!peers[sender]) createPeer(sender, false);
        const pc = peers[sender];

        if(signal.candidate) {
             try { await pc.addIceCandidate(new RTCIceCandidate(signal.candidate)); } catch(e){}
        } else {
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(signal));
                if(signal.type === 'offer') {
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    socket.emit('signal', { target: sender, signal: pc.localDescription });
                }
            } catch(e) { console.error(e); }
        }
    });

</script>
</body>
</html>
